#!/usr/bin/perl -w
# $Id$
# This Script (examplix) was created by Rüdiger Beck
# It is released under the GPL Version 2 or higher
# For Bugs send mail to:
# jeffbeck@web.de

# Bibliotheken
use strict;
use Getopt::Long;
use Spreadsheet::WriteExcel;
use Spreadsheet::ParseExcel;

# configure this
# factor for exams
my $exam_factor=2;
# factor for registration marks (Anmeldenoten)
my $reg_mark_factor=1;


my $create="";
my $tasks="";
my $result="";
my $pro_name="";
my $help=0;
my $year=0;
my $midyear=0;
my $exam=0;
my $mode="";
my $final=0;

my %hash=();


my @students=();
my $students_num=0;
my %teachers_seen=();

my @subjects=();
my @problems=();
my @averages_class=();
my $average_class=0;
my @sums_class=();
my $sum_class=0;
my $students_num_without_subject=0;
     
my @days=();     
my @factors=();     

my $max_problems=7;

my %translate_key_short=();
my %translate_key_long=();

my @all_users=();
my %all_users=();

# hash of hash of hash ...
my %all_marks=();

# hash of registration marks
my %reg_marks=();

my %all_correctors=();

my @numstrings=();

my @final_subjects = ();
my @final_subjects_loop = ();
my @final_subjects_show = ();
my %subject_type = ();
my @final_list=();

my $final_list_ref=\@final_list;

my %valid_final_marks = qw(
   1,0  1
   2,0  2
   3,0  3
   4,0  4
   5,0  5
   6,0  6
);

my %valid_override_marks = qw(1 valid 
                              2 valid 
                              3 valid 
                              4 valid 
                              5 valid
                              6 valid
                             );


my $not_taken_string="*)";
my %not_taken_comments = (
   -2000 => "$not_taken_string Zweitausbildung",
   -3000 => "$not_taken_string Fachhochschulreife",
   -4000 => "$not_taken_string Hochschulreife",
);



# Parsen der Optionen
my $testopt=GetOptions(
           "create|c=s" => \$create,
           "tasks|t=s" => \$tasks,
           "result|r=s" => \$result,
           "help|h" => \$help,
           "year|schuljahr|jahr" => \$year,
           "exam|pruefung" => \$exam,
           "halfyear|midyear|mid-year|term|halbjahr" => \$midyear,
           "final" => \$final,
          );

# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

&get_translation();

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
examplix (EXAMs Per LInux/uniX) is a tool to divide the correction of a larger exam into smaller chunks for a number of people and put together these chunks and calsulate a mark.  

Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info

What type of calculation
  --year / --jahr / --schuljahr
  --midyear / halbjahr
  --exam / pruefung

What to do
  -c  / --create examname
  -t  / --tasks examname
  -r  / --result examname
  --final

Please see the examplix(1) man pages for full documentation
');
   print "\n";
   exit;
}





# --Mid-Year
if ($midyear==1){
    $mode="midyear";
    @numstrings=("Halbjahr");
}


# --Year
if ($year==1){
    $mode="year";
    @numstrings=("Schuljahr");
}


# --exam
if ($exam==1){
    $mode="exam";
    @numstrings=&get_correction_numstrings();
}


# check the mode
if ($exam+$year+$midyear!=1){
        print "\nSie müssen --jahr, --halbjahr oder --pruefung angeben!\n\n";
	exit;
    }


# --create
if ($create ne "") {
  $pro_name=$create;
  #
  if (-e $create){
      print "\nERROR: \n",
            "   Exam-Directory $create exists already\n",
            "   I'm doing nothing!\n\n";
  } else {
     &create_exam($create); 
  }
}


# --tasks
if ($tasks ne "") {
    $pro_name=$tasks;
    #$mode = &fetch_mode($tasks);
    @students=&get_students($tasks);
    %hash = &create_task_hash($tasks);
    print "Creating the following Task-Files of exam $tasks:\n";
    while (my ($file,$prob) = each %hash ){
        print "   $file with Problems: $prob \n";
        &create_xls_file($file,$prob);
    }
    &create_xls_reg_mark_file();
}


# --result
if ($result ne "") {
  $pro_name=$result;
  @final_subjects = &get_all_subjects();
  @final_subjects_loop = &get_loop_subjects();
  @final_subjects_show = &get_show_subjects();

  %subject_type=&get_show_subjects("hash");

  @days = &get_days();

  # create big hash
  %hash = &create_task_hash($result);
  while (my ($file,$prob) = each %hash ){
      &read_xls_file($file,$prob);
  }

  # create reg_mark_hash
  &read_xls_reg_mark_file();

  # create dir if not there already
  if (not -e "$result/results/${mode}"){
      system ("mkdir -p $result/results/${mode}");     
  }
  # create dir if not there already
  if (not -e "$result/collect/${mode}"){
      system ("mkdir -p $result/collect/${mode}");     
  }

  &latex_preamble();

  @subjects = &get_all_subjects();

  my @stud_res=&get_students($result);
  $students_num=$#stud_res+1;

  foreach my $sub (@subjects){
    my $cline_max;
    @averages_class=();
    $average_class=0;
    @sums_class=();
    $sum_class=0;
    $students_num_without_subject=0;
    print "\n################Creating Result of subject $sub ...\n\n";
    &set_data_for_subject($sub);

    # hack: if Erstkorrektur, then dont go for avarage
    &latex_headers($sub,$numstrings[0]);
    my $i=0;
    foreach my $student (@stud_res){
      print "\n##########  Working on student $student ... ##########\n";
      my $average_1=0;
      my $average_1_format="";
      my $average_2=0;
      my $average_2_format="";
      my $average_3=0;
      my $average_3_format="";
      my $missing_1=0;
      my $missing_2=0;
      my $missing_3=0;
      my %marks=();      

      # increase student counter
      $i++;
      my ($last,$first)=split(/,/,$student);

      foreach my $num (@numstrings){
         print " ### $num ...\n";
         my $sum=0;
         my $divisor=0;
         my $all_average=0;

         my $line="";
         if ($num eq "Erstkorrektur"){
            $line="\\textbf{$i} & \\textbf{".$last.",} & ";
	 } elsif ($num eq "Zweitkorrektur"){
            $line="  & \\textbf{".$first."} & ";
	 } elsif ($num eq "Drittkorrektur"){
            $line="  & & ";
         } elsif ($num eq "Halbjahr" or $num eq "Schuljahr"){
            $line="\\textbf{$i} & \\rule[-1mm]{0mm}{5mm}\\textbf{".
                  $last.", ".$first."} & ";
         }

         # number of columns, starting with 0
         my $j=0;
         open (CONF, "$result/${mode}.cfg") || die "Fehler: $!";


	 print "\nOPENING file \n\n";

         while (<CONF>){
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/ or 
               /^\s/ or
               /^SHOW_SUBJECT/ or
               /^LOOP_SUBJECT/ 
              ){ # # am Anfang bedeutet Kommentarzeile
               next;
            }
	    chomp();
            my ($day,
                $problem,
                $subject,
                $factor,
                $corr_1,
                $group_1,
                $corr_2,
                $group_2,
                $corr_3,
                $group_3)=split(/;/);
            my $corrector;
            if ($num eq "Erstkorrektur"){
		$corrector=$corr_1;
            } elsif ($num eq "Zweitkorrektur"){
		$corrector=$corr_2;
            } elsif ($num eq "Drittkorrektur"){
		$corrector=$corr_3;
            } else {
                # mid-year and year
		$corrector=$corr_1;
            }             

            if ($subject eq $sub) {
               # create a column
		print "\nFOUND Subject $sub \n\n";
#               print "    Fetching data for $problem ...\n";
               my @result = &get_result_quick($student,
                                              $corrector,
                                              $subject,
                                              $num,
                                              $day,
                                              $problem);
               print "      * $result[0] $problem of $student corrected",
                     " by $result[2] is $result[3] \n";
               # make a copy of result
               # result[3] is used to calculate average, ...
               # result_format is used as a string to print

               # add the result for averages
 
               ## ????? avoids error
               if (not defined $sums_class[$j]){
                   $sums_class[$j]=0;
               }

#  	       if ($result[3]!=-100 and $result[3]!=-200){
               if ($result[3]>0){   
	           $sums_class[$j]=$result[3]+$sums_class[$j];
               }

               my $result_format=&format($result[3]);
               if ($num eq "Erstkorrektur"){
                   if ($result[3]==-100){
                      $line = $line."   \\colorbox{red}{---} &";
                      $missing_1=1;
                   } elsif ($result[3]==-200) {
                      $line = $line."   \\colorbox{red}{NF} &";
                      $missing_1=1;
                   } else {                     
                      $line = $line."   \\textcolor{red}{".$result_format."} &";
                   }
               } elsif ($num eq "Zweitkorrektur"){
                   if ($result[3]==-100){
                      $line = $line."   \\colorbox{green}{---} &";
                      $missing_2=1;
                   } elsif ($result[3]==-200) {
                      $line = $line."   \\colorbox{green}{NF} &";
                      $missing_2=1;
                   } else {                     
                      $line = $line."   \\textcolor{green}{".$result_format."} &";
	           }
               } elsif ($num eq "Drittkorrektur"){
                   if ($result[3]==-100){
                      $line = $line."   \\colorbox{blue}{---} &";
                      $missing_3=1;
                   } elsif ($result[3]==-200) {
                      $line = $line."   \\colorbox{blue}{NF} &";
                      $missing_3=1;
                   } else {                     
                      $line = $line."   \\textcolor{blue}{".$result_format."} &";
	           }
               } elsif ($num eq "Halbjahr"){
                   if ($result[3]==-100){
                      $line = $line."   \\colorbox{yellow}{---} &";
                      $missing_1=1;
                   } elsif ($result[3]==-200) {
                      $line = $line."   \\colorbox{yellow}{NF} &";
                      $missing_1=1;
                   } elsif ($result[3]==-2000 or
                            $result[3]==-3000 or 
                            $result[3]==-4000) {
                      $line = $line."   \\colorbox{yellow}{---} &";
                      $missing_1=1;
                   } else {                     
                      $line = $line."   \\textcolor{yellow}{".$result_format."} &";
		   }
               } elsif ($num eq "Schuljahr"){
                   if ($result[3]==-100){
                      $line = $line."   \\colorbox{orange}{---} &";
                      $missing_1=1;
                   } elsif ($result[3]==-200) {
                      $line = $line."   \\colorbox{orange}{NF} &";
                      $missing_1=1;
                   } elsif ($result[3]==-2000 or
                            $result[3]==-3000 or 
                            $result[3]==-4000) {
                      $line = $line."   \\colorbox{orange}{---} &";
                      $missing_1=1;
                   } else {                     
                      $line = $line."   \\textcolor{orange}{".$result_format."} &";
		   }
               }

               # calculate if result[3] is OK 
               if ($result[3]>0){   
                  $sum = $sum + $result[3]*$factor;
                  $divisor = $divisor + $factor;
	       }
               $j++;
               print "##########  ... Working on student ",
                     "$student DONE ##########\n\n";
           } # end: foreach column
	} # end while 


	 $cline_max=$#problems+4;
         if ($num eq "Erstkorrektur"){
             if ($divisor!=0){
                $average_1 = $sum / $divisor;
	     } else {
                $average_1 = -100;
	     }
             $average_1 = &one_decimal($average_1);	        
             $average_1_format = &format($average_1);
             $sum = &format($sum);
             $line = $line." \\textcolor{red}{".$sum."}";
             if ($missing_1==1){
                 $line = $line." & \\colorbox{red}{---} &";
              } else {
                 $line = $line." & \\textcolor{red}{".$average_1_format."} &"; 
                 # save the result for later printing
                 $all_users{$student}{"$sub-1"}=$average_1;
             }

#                $line = $line."\\\\\\cline*{2-${cline_max}} \n";
#                $line = $line."\\\\*\\cline{2-${cline_max}} \n";
# makes no pagebreak
             $line = $line."\\\\* \n";

         } elsif ($num eq "Zweitkorrektur"){
             if ($divisor!=0){
                $average_2 = $sum / $divisor;
	     } else {
                $average_2 = -100;
	     }
             $average_2 = &one_decimal($average_2);
             $average_2_format = &format($average_2);
             $sum = &format($sum);
             $line = $line." \\textcolor{green}{".$sum."}";
             if ($missing_2==1){
                $line = $line." & \\colorbox{green}{---} &"; 
	     } else {
                $line = $line." & \\textcolor{green}{".$average_2_format."} &"; 
  	        # save the result for later printing
	        $all_users{$student}{"$sub-2"}=$average_2;
	     }

             if (defined $numstrings[2]){
                 if ($numstrings[2] eq "Drittkorrektur"){
                     # Drittkorrektur will follow
                     $line = $line."\\\\* \n";
                 } else {
                     print "ERROR: $numstrings[2] \n";
		     exit;
                 }
             } else {
                 # Calculate the average
                 $all_average = 0.5*($average_1 + $average_2 );
                 $all_average = &one_decimal($all_average);
                 # save the result for later printing
                 $marks{"$sub"}=$all_average;               
                 # save it in Anmeldenoten hash for later calculation
                 my $subject_short=&translate_to_short($sub);

                 if ($missing_1==0 
                     and $missing_2==0
                     and not defined $numstrings[2]){
                    $reg_marks{$student}{"exam"}{$subject_short}=$all_average;
                    $all_average = &format($all_average);
                    $line = $line." \\LARGE \\textbf{".$all_average."}";
   	            $all_users{$student}{"$sub-av"}=$all_average;
                  } else {
                    $line = $line." \\LARGE \\textbf{---}"; 
                 }
                 $line = $line."\\\\ \\hline\\hline\\pagebreak[3]\n\n";
	     }

         } elsif ($num eq "Drittkorrektur"){
             if ($divisor!=0){
                $average_3 = $sum / $divisor;
	     } else {
                $average_1 = -100;
	     }
             $average_3 = &one_decimal($average_3);
             $average_3_format = &format($average_3);
             $sum = &format($sum);
             $line = $line." \\textcolor{blue}{".$sum."}";
             if ($missing_3==1){
                $line = $line." & \\colorbox{blue}{---} &"; 
	     } else {
                $line = $line." & \\textcolor{blue}{".$average_3_format."} &"; 
  	        # save the result for later printing
	        $all_users{$student}{"$sub-3"}=$average_3;
	     }

             $all_average = ($average_1 + $average_2 + $average_3)/3;
             $all_average = &one_decimal($all_average);
             # save the result for later printing
             $marks{"$sub"}=$all_average;               
             $all_average = &format($all_average);
             if ($missing_1==0 and $missing_2==0 and $missing_3==0){
                $line = $line." \\LARGE \\textbf{".$all_average."}"; 
                $all_users{$student}{"$sub-av"}=$all_average;
             } else {
                $line = $line." \\LARGE \\textbf{---}"; 
             }
             $line = $line."\\\\ \\hline\\hline\\pagebreak[3]\n\n";
         } elsif ($num eq "Halbjahr"){
             if ($divisor!=0){
                $average_1 = $sum / $divisor;
	     } else {
                $average_1 = -100;
	     }
	     # save the result for later printing
             $average_1 = &one_decimal($average_1);	        

             # add the result to calculate average
             $sum_class=$sum_class+$average_1;           

             $average_1_format = &format($average_1);
             $sum = &format($sum);
             $line = $line." \\textcolor{yellow}{".$sum."}";
             if ($missing_1==0){
                $line = $line." & \\large \\textbf{".$average_1_format."}"; 
	        $all_users{$student}{"$sub-1"}=$average_1;
             } else {
                $line = $line." & \\large \\textbf{---}"; 
	     }
             $line = $line."\\\\ \\hline\\pagebreak[3]\n\n";
          } elsif ($num eq "Schuljahr"){
             if ($divisor!=0){
                $average_1 = $sum / $divisor;
	     } else {
                $average_1 = -100;
	     }
	     # save the result for later printing
             $average_1 = &one_decimal($average_1);	        

             # add the result to calculate average
             if ($average_1<=0){
                $students_num_without_subject++
	     } else {
                $sum_class=$sum_class+$average_1;
             }

             $average_1_format = &format($average_1);
             $sum = &format($sum);
             $line = $line." \\textcolor{orange}{".$sum."}";
             if ($missing_1==0){
                $line = $line." & \\large \\textbf{".$average_1_format."}"; 
       	        $all_users{$student}{"$sub-1"}=$average_1;
             } else {
                $line = $line." & \\large \\textbf{---}"; 
	     }
             $line = $line."\\\\ \\hline\\pagebreak[3]\n\n";
         } 
             print LATEX $line;
     } # end numstrings
    push @all_users , [ $student, { %marks } ];
    } # end:  foreach student
    &latex_footer($numstrings[0]);
    print LATEX "\\end{longtable}\n";
    if ($#problems > $max_problems){
       print LATEX "\\end{landscape}\n";
    }
  }
  # print overview 
  if ($exam==1){
     &print_all_results_per_user();
  } else {
     &print_all_results();
  }
  &latex_end();
  &compile_latex();
}










############################################################
# SUB
############################################################

## 
sub fetch_mode_not_used {
    my ($option) = @_;
    my $mode ="";
    my $exam=0;
    my $year=0;
    if (-e "$option/exam.cfg"){
	$exam=1;
        $mode="exam";
    }
    if (-e "$option/year.cfg"){
        $year=1;
        $mode="year";
    }

    if ($exam==1 and $year==1){
	print "\nERROR: Could not determine mode (year or exam).\n";
	print "       Delete $option/exam.cfg or \n";
	print "       Delete $option/year.cfg \n\n";
        exit;
    } elsif ($exam==0 and $year==0){
	print "\nERROR: Could not determine mode (year or exam).\n";
	print "       Create $option/exam.cfg or \n";
	print "       Create $option/year.cfg \n\n";
        exit;
    }
    print "##### Running in $mode-mode\n";
    return $mode;
}



sub read_xls_file {
    my ($file,$prob) = @_;
    my @problems = split(/;/,$prob);
    my ($teacher,$subject,$num,$day) = split(/_/,$file);
    print "Reading $file for Values: $prob \n";

    # adding to hash problem-> corrector
    $all_correctors{$day}{$prob}{$subject}=$teacher;  
 
    my $path = "$result/collect/${mode}/$file";
    if (not -e "$result/collect"){
        system("mkdir $result/collect");
    }

    my $oBook = Spreadsheet::ParseExcel::Workbook->Parse("$path");
    my($iR, $iC, $oWkS, $oWkC);
    foreach my $oWkS (@{$oBook->{Worksheet}}) {
       my $column=0;
       foreach my $pro (@problems){
          # check correct column
          $column++; 
          my $oWkC = $oWkS->{Cells}[3][$column];
          my $header=$oWkC->Value;
          print "   I try to read $pro from column with header $header \n";
          if ($pro eq $header){
              # Reading the values
              for(my $iR = 4;
                 defined $oWkS->{MaxRow} && $iR <= $oWkS->{MaxRow} ; $iR++) {
                 my $oWkC = $oWkS->{Cells}[$iR][0];
                 my $oWkC2 = $oWkS->{Cells}[$iR][$column];
                 my $student = $oWkC->Value;
                 my $mark = $oWkC2->Value;
                 if ($mark eq ""){
                     $mark=-100;
                 } elsif ($mark eq "zweit" or $mark eq "ZWEIT"){
                     $mark=-2000;
                 } elsif ($mark eq "fhsr" or $mark eq "FHSR"){
                     $mark=-3000;
                 } elsif ($mark eq "hsr" or $mark eq "HSR"){
                     $mark=-4000;
                 }
                 print "   Saving: $student $teacher $subject ",
                       "$num $day $pro has mark $mark \n";
                 # push the mark in the hash
                 $all_marks{$student}{$teacher}{$subject}{$num}{$day}{$pro}=$mark;
	      }
          } else {
	      print "\nERROR: wrong Header\n\n";
          }
       }
    }
}


sub read_xls_reg_mark_file {
    my $teacher="class-teacher";
    my $file="";
    if ($exam==1){
        $file="Anmeldenoten_all.xls";
    } else {
        $file="override_all.xls";
    }
    my $path = "$result/collect/${mode}/$file";
    my @problems = &get_loop_subjects();

    my $oBook = Spreadsheet::ParseExcel::Workbook->Parse("$path");
    my($iR, $iC, $oWkS, $oWkC);
    foreach my $oWkS (@{$oBook->{Worksheet}}) {
       my $column=0;
       foreach my $pro (@problems){
          my $subject_short=&translate_to_short($pro);
          # check correct column
          $column++; 
          my $oWkC = $oWkS->{Cells}[3][$column];
          my $header=$oWkC->Value;
          print "   I try to read $pro ($subject_short) ".
                "from column with header $header \n";
          if ($subject_short eq $header){
              # Reading the values
              for(my $iR = 4;
                 defined $oWkS->{MaxRow} && $iR <= $oWkS->{MaxRow} ; $iR++) {
                 my $oWkC = $oWkS->{Cells}[$iR][0];
                 my $oWkC2 = $oWkS->{Cells}[$iR][$column];
                 my $student = $oWkC->Value;
                 my $mark = $oWkC2->Value;
                 if ($mark eq ""){
                     $mark=-100;
                 } elsif ($mark eq "zweit" or $mark eq "ZWEIT"){
                     $mark=-2000;
                 } elsif ($mark eq "fhsr" or $mark eq "FHSR"){
                     $mark=-3000;
                 } elsif ($mark eq "hsr" or $mark eq "HSR"){
                     $mark=-4000;
                 }
                 print "   Saving: $student $teacher $subject_short $mark \n";
                 # push the mark in the hash
 	         $reg_marks{$student}{$teacher}{$subject_short}=$mark;
	      }
          } else {
	      print "\nERROR: wrong Header\n\n";
          }
       }
    }
}



sub print_all_results_per_user {
   print LATEX "\\newpage \n\n";
   #command for the area under the name for tickmarks
   print LATEX '
\newcommand{\finres}[1]{%
\setlength{\unitlength}{1mm}
\begin{picture}(0,0)
  % frame for final result
  \put(35,0){\framebox(10,6){#1}}
  \put(31,2.2){$\varnothing$} %or use \O{}
  % tickboxes
  \put(-2,0){\framebox(4,4){}}
  \put(3.5,1){\footnotesize Preis}
  \put(-2,5){\framebox(4,4){}}
  \put(3.5,6){\footnotesize Auszeichnung}
  \put(-2,10){\framebox(4,4){}}
  \put(3.5,11){\footnotesize Belobigung}
  \put(-2,15){\framebox(4,4){}}
  \put(3.5,16){\footnotesize Schulprüfung bestanden}
  %\put(0,5){\line(1,0){60}}
  %\put(57,0){\makebox(0,10)[b]{#1}}
\end{picture} \hfill
}
';


# is always exam ???
   if ($mode eq "exam"){
       print LATEX "\\section{Prüfungs-Notenliste}\n\n";
   } elsif ($mode eq "year"){
       print LATEX "\\section{Jahreszeugnis-Notenliste}\n\n";
   } elsif ($mode eq "midyear"){
       print LATEX "\\section{Halbjahreszeugnis-Notenliste}\n\n";
   }

   my @students=&get_students($result);   
   print "@students \n";
   my $i=0;

   # calculate span of \cline
   my $from=3;
   my $to=$#final_subjects_show+4;

   # create the table header 
   my $latex_table_header="\\begin{tabular}{|p{6mm}|p{40mm}|c|";
   foreach my $subject (@final_subjects_show){
      print $latex_table_header=$latex_table_header."p{15mm}|";
   }
   print  $latex_table_header=$latex_table_header."p{50mm}|} \\hline \n";


   # create the first line with headings
   my $first_line_suffix="& & ";
   foreach my $subject (@final_subjects_show){
      my $subject_short=&translate_to_short($subject);
       $first_line_suffix=$first_line_suffix.
          " \\multicolumn{1}{c|}{$subject_short} & ";
   }
   $first_line_suffix=$first_line_suffix.
        " \\multicolumn{1}{l|}{Bemerkungen} \\\\  \\hline \\hline\n";

   # create the table footer 
   my $latex_table_footer="\\end{tabular}";

   my @extensions=();
   if (defined $numstrings[2]){
       if ($numstrings[2] eq "Drittkorrektur"){
         @extensions=("-1","-2","-3","-av");
       } else {
	   print "ERROR: $numstrings[2] \n";
           exit;
       } 
   } else {
      @extensions=("-1","-2","-av"); 
   }


   foreach my $student (@students){
       my $not_taken_comment="";
      $i++;
      print LATEX "$latex_table_header";

      print LATEX "\\multicolumn{1}{|r|}{\\rule[-2mm]{0mm}{7mm}\\textbf{$i}} & \\textbf{$student} ";
      print LATEX "$first_line_suffix";

      # Anmeldenoten
      print LATEX "\\multicolumn{2}{|l|}{} & Anmeld. & ";
      foreach my $subject (@final_subjects_show){
         my $teacher="class-teacher";
         my $subject_short=&translate_to_short($subject);
         print "\nWorking on $subject($subject_short)\n";

         # if show subject, leave empty
         if ($subject_type{$subject_short} eq "SHOW_SUBJECT"){
             print LATEX " \\multicolumn{1}{c|}{} & ";
             next;
         }         

         my $mark=$reg_marks{$student}{$teacher}{$subject_short};
         my $string="";
         if (not defined $mark or $mark eq ""){
     	    $mark="---";
         } elsif ($mark<-1000) {
	     $string="\\textcolor{blue}{$not_taken_string}";
         } elsif ($mark==-100) {
	     $string="\\colorbox{blue}{---}";
         } else {
            $mark = &format($mark,"integer");
            $string="\\textcolor{blue}{$mark}";
         }
         print "  Registration Mark of $student in $subject is $mark \n";
         print LATEX " \\multicolumn{1}{c|}{$string} & ";
      }
      print LATEX "\\\\  \\cline{$from-$to} \n";

      foreach my $ext (@extensions){
         print LATEX "\\multicolumn{2}{|l|}{}  & Prüf$ext & ";

         # results of exam
         foreach my $subject (@final_subjects_show){
	    my $string=$subject.$ext;
            my $subject_short=&translate_to_short($subject);

            # if show subject, leave empty
            if ($subject_type{$subject_short} eq "SHOW_SUBJECT" or
                $subject_type{$subject_short} eq "LOOP_SUBJECT" ){
                print LATEX " \\multicolumn{1}{c|}{} & ";
                next;
            }         

            my $mark=$all_users{$student}{$string};
            if (not defined $mark or $mark eq ""){
		$mark="---";
            } else {
                $mark = &format($mark);
            }
            if ($ext eq "-1"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{green}{$mark}}  & ";
            } elsif ($ext eq "-2"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{green}{$mark}}  & ";
            } elsif ($ext eq "-3"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{green}{$mark}}  & ";
            } elsif ($ext eq "-av"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{green}{$mark}}  & ";     
            }
         }
         print LATEX "\\\\  \\cline{$from-$to} \n";
      }

      # Endnote
      my $end_line="";
      foreach my $subject (@final_subjects_show){
          my $reg_mark;
          my $subject_short=&translate_to_short($subject);
 
          # if show subject, leave empty
          if ($subject_type{$subject_short} eq "SHOW_SUBJECT"){
              $end_line=$end_line." \\multicolumn{1}{c|}{} & ";
              next;
          }         

          # if loop subject, print reg_mark
          if ($subject_type{$subject_short} eq "LOOP_SUBJECT"){
              $reg_mark=$reg_marks{$student}{"class-teacher"}{$subject_short};
              if ($reg_mark==-100){
                  $end_line=$end_line." \\multicolumn{1}{c|}{\\colorbox{red}{---}} & ";
	      } else {
                  $end_line=$end_line." \\multicolumn{1}{c|}{\\textcolor{red}{$reg_mark}} & ";
	      }
              next;
          }         


          # calculating result (exam and reg_mark)
          my $exam=$reg_marks{$student}{"exam"}{$subject_short};

          $reg_mark=$reg_marks{$student}{"class-teacher"}{$subject_short};

          # check if defined
          if (not defined $exam){
              $exam=-100;
              print "No exam mark found\n";
          }
          if (not defined $reg_mark){
              $reg_mark=-100;
              print "No registration mark found\n";
              #exit;
          } 

          # overwrite school_exam if correct calculation is not possible
          if ($reg_mark<-1000){
	      $not_taken_comment=$not_taken_comments{$reg_mark};
             $end_line=$end_line.
                " \\multicolumn{1}{c|}{\\textcolor{red}{$not_taken_string}} & ";
          } elsif ($exam==-100 or $reg_mark==-100){
             # no calculation possible
             $end_line=$end_line.
                " \\multicolumn{1}{c|}{\\colorbox{red}{---}} & ";
	  } else {
             my $school_exam=($exam_factor*$exam+$reg_mark_factor*$reg_mark)/3;
                $school_exam = &final_mark($school_exam);
                $school_exam = &format($school_exam,"integer");
             # save it for calculating all average
             $reg_marks{$student}{"school-exam"}{$subject_short}=$school_exam;
             $end_line=$end_line.
                " \\multicolumn{1}{c|}{\\textcolor{red}{$school_exam}} & ";
	  }
      }

      # calculate average of all marks
      my $school_exam_mark=0;
      my $school_exam_sum=0;
      foreach my $subject (@final_subjects){
          my $subject_short=&translate_to_short($subject);
	  print "$subject_short \n";
          if (defined $reg_marks{$student}{"school-exam"}{$subject_short}){
              $school_exam_sum=
              $school_exam_sum+$reg_marks{$student}{"school-exam"}{$subject_short};
          } else {
              # result cannot be calculated
              $school_exam_mark=-100;
              last;
          }
      }

      if ($school_exam_mark==-100){
          $school_exam_mark="\\colorbox{red}{---}";
      } else {
          # calculate
          my $number=$#final_subjects+1;
          $school_exam_mark=$school_exam_sum/$number;
          $school_exam_mark = &one_decimal($school_exam_mark);
          $school_exam_mark = &format($school_exam_mark);
          $school_exam_mark="\\textcolor{red}{\\large $school_exam_mark}";
      }


      # prepend stuff to final line and finish the line
      $end_line="\\multicolumn{2}{|l|}{\\finres{$school_exam_mark}} & Note & ".
                $end_line.
                " \\multicolumn{1}{|l|}{$not_taken_comment} \\\\  \\hline \n";
 
      print LATEX "$end_line";
 
      print LATEX "$latex_table_footer \n\n";
      print LATEX "\\bigskip \n\n";
  }
}



# perhaps not necessary anymore
sub print_all_results{
   # print the marklist for all subjects and all students 
   # at the end of the document
   print LATEX "\\newpage \n\n";
   if ($mode eq "exam"){
       print LATEX "\\section{Prüfungs-Notenliste}\n\n";
   } elsif ($mode eq "year"){
       print LATEX "\\section{Jahreszeugnis-Notenliste}\n\n";
   } elsif ($mode eq "midyear"){
       print LATEX "\\section{Halbjahreszeugnis-Notenliste}\n\n";
   }
   print LATEX "\\begin{longtable}{|r|l||";

   if ($mode eq "exam"){
        # Verhalten und Mitarbeit
       print LATEX "c|c|";
   } elsif ($mode eq "year"){
        # Verhalten und Mitarbeit
       print LATEX "p{8mm}|p{8mm}||";
   } elsif ($mode eq "midyear"){
        # Verhalten und Mitarbeit
       print LATEX "p{8mm}|p{8mm}||";
   }
  
   foreach my $subject (@final_subjects){
      print LATEX "p{25mm}|";
   }
   print LATEX "l|} \\hline \n";
   print LATEX "\\rule[-3mm]{0mm}{9mm}Nr. & Name & ";

   if ($mode eq "exam"){
       # Verhalten und Mitarbeit
       print LATEX "& ";
   } elsif ($mode eq "year"){
       print LATEX " \\multicolumn{1}{c|}{V} & \\multicolumn{1}{c||}{M} &";
   } elsif ($mode eq "midyear"){
       print LATEX " \\multicolumn{1}{c|}{---} & \\multicolumn{1}{c||}{---} &";
   }


   foreach my $subject (@final_subjects){
      my $subject_short=&translate_to_short($subject);
       print LATEX " \\multicolumn{1}{c|}{$subject_short} & ";
   }
   print LATEX " \\multicolumn{1}{c|}{Bemerkungen} \\\\  \\hline \\hline\n";
   &print_all_results_year();
   print LATEX "\\end{longtable}\n";
   &print_legend_line();
}


sub print_legend_line {
   print LATEX "\nErläuterungen:\\colorbox{red}{---}: keine Note ermittelbar, ",
               "\\textcolor{green}{Note}: zwischen 2 Noten, ",
               "\\textcolor{red}{Note}: nicht ausreichend, ",
               "\\textcolor{blue}{Note}: von Hand abgeändert";
}


# perhaps not necessary anymore
sub print_all_results_exam {
   # create output for exam
#   my @extensions=("-1","-2","-av"); 
   my @extensions=();
#   if ($numstrings[2] eq "Drittkorrektur"){
   if (defined $numstrings[2]){
       if ($numstrings[2] eq "Drittkorrektur"){
         @extensions=("-1","-2","-3","-av");
       } else {
	   print "ERROR: $numstrings[2] \n";
           exit;
       } 
   } else {
      @extensions=("-1","-2","-av"); 
   }
   my @students=&get_students($result);
   my $i=0; 
   foreach my $student (@students){
      $i++;
      foreach my $ext (@extensions){
         if ($ext eq "-1"){
            print LATEX "$i  & $student & Prüf$ext & ";
	 } else {
            print LATEX " & & Prüf$ext & ";
	 }
         foreach my $subject (@final_subjects){
	    my $string=$subject.$ext;
            my $mark=$all_users{$student}{$string};
            if (not defined $mark or $mark eq ""){
		$mark="---";
            } else {
                $mark = &format($mark);
            }
            if ($ext eq "-1"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{red}{$mark}}  & ";
            } elsif ($ext eq "-2"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{green}{$mark}}  & ";
            } elsif ($ext eq "-3"){
                print LATEX " \\multicolumn{1}{c|}{\\textcolor{blue}{$mark}}  & ";
            } elsif ($ext eq "-av"){
                print LATEX " \\multicolumn{1}{c|}{$mark}  & ";     
            }
         }
         if ($ext eq "-av"){
            print LATEX "\\\\  \\hline \\hline\n";
         } else {
            print LATEX "\\\\  \\hline \n";
         }
      }
   }

}



sub print_all_results_year {
   # create output for exam
   my $ext="-1";
   my @students=&get_students($result);
   my $i=0; 
   foreach my $student (@students){
         my $not_taken_comment="";
         $i++;
         print LATEX "$i \\rule[-2.3mm]{0mm}{7.1mm} & $student & & &";
         foreach my $subject (@final_subjects){          
            my $subject_short=&translate_to_short($subject);
	    my $string=$subject.$ext;
            my $mark=$all_users{$student}{$string};
            #print "Student: $student \n";
            #print "String:  $string \n";
            #print "Mark:    $mark \n";
            my $final_mark;
            my $final_mark_colored;
            my $override_mark=
               $reg_marks{$student}{"class-teacher"}{$subject_short};

            if (not defined $mark or $mark eq "" or $mark==0){
                #print "Resetting Mark \n";
		$mark="";
                $final_mark="---";
                $final_mark_colored="\\colorbox{red}{---}";
            } elsif ($mark==-100){
                if (not defined $override_mark){
                   $mark="";
                   $final_mark="---";
                   $final_mark_colored="\\colorbox{red}{---}";
                } elsif ($override_mark<-1000){
	           $not_taken_comment=$not_taken_comments{$override_mark};
                   $mark="";
                   $final_mark="---";
                   $final_mark_colored="\\footnotesize $not_taken_string";
	        } else {
                   $mark="";
                   $final_mark="---";
                   $final_mark_colored="\\colorbox{red}{---}";
	        }
            } elsif ($mark<0){
                $mark="";
                $final_mark="---";
                $final_mark_colored="-p-";
            } else {
                $final_mark=&final_mark($mark);
                # colorize marks
                if ($final_mark==5 or $final_mark==6){
		    $final_mark_colored="\\textcolor{red}{".$final_mark."}";
                } elsif ($mark==1.5 
                      or $mark==2.5 
                      or $mark==3.5
                      or $mark==4.5
                      or $mark==5.5){
		    $final_mark_colored="\\textcolor{green}{".$final_mark."}";
                } else {
                    $final_mark_colored = $final_mark;
                }
                $mark = &format($mark);
            }
  
            # use overrride mark if given
            if (exists $valid_override_marks{$override_mark}){
                $mark = &format($mark);
                $final_mark=$override_mark;
                $final_mark_colored="\\textcolor{blue}{$override_mark}";
            }

            # math mode
            print LATEX "\n \\multicolumn{1}{c|}{",
                        "\\textbf{\\Large\\rule{1mm}{0mm}",
                        "\\hspace{-1.4mm}${final_mark_colored}}",
                        "\\raisebox{-1mm}{\\tiny ${mark}}",
                        "} & ";
         }
         print LATEX "\n \\footnotesize $not_taken_comment \\\\  \\hline \n";
   }

}





sub format {
    # if $type is "integer", do not append ,0
    my ($number,$type) = @_;
    if (not defined $type){
        $type="";
    }
    if ($number eq ""){
        # do nothing
    } else {
       # replace dots with commas
       $number =~ s/\./,/;
       if ($type eq "integer"){
           if (exists $valid_final_marks{$number}){
               $number=$valid_final_marks{$number};
           }
       }
       # append ,0 again, when necessary
       if (not $number =~ m/,/ and $type ne "integer"){
          $number = $number.",0"
       }
    }
    return $number;
}


sub dot_to_comma {
    # replace dot with comma
    my ($number) = @_;
    $number =~ s/\./,/;
    return $number;
}


sub get_all_subjects {
    my @sub = &get_subjects("all");
    return @sub;
}

sub get_loop_subjects {
    # all subjects + loop
    my @sub = &get_subjects("loop");
    return @sub;
}

sub get_show_subjects {
    my ($return) = @_;
    # all subjects + loop + show
    if (not defined $return){
        $return="array";
    }
    if ($return eq "array"){
        my @sub = &get_subjects("show");
        return @sub;
    } elsif ($return eq "hash"){
        my @sub = &get_subjects("show","hash");
        return @sub;
    }
}


sub get_days {
   my %days=();
   my @days=();
   open (CONF, "<$result/${mode}.cfg") || die "Fehler: $!";
   while (<CONF>){
      s/^ //g; # Leerzeichen am Zeilenangfang entfernen
      if(/^\#/ or 
         /^\s/ or
         /^SHOW_SUBJECT/ or
         /^LOOP_SUBJECT/ 
        ){ # # am Anfang bedeutet Kommentarzeile
          next;
      }
      chomp();
      my ($day)=split(/;/);

      # days
      if (not exists $days{$day}){
          $days{$day}=1;
          # add to list if seen once
          if ($mode eq "exam"){
             push @days, $day;
          }
      }
   }
   my $string=join(",",@days);
   print "Days: $string\n";
   return @days;
}

sub get_subjects {
   my ($range,$return) = @_;
   if (not defined $return){
       $return="array";
   }
   my $loop=0;
   my $show=0;
   if ($range eq "loop"){
       # show all subjects
       $range="all";
       # show loop subjects
       $loop=1;
   }

   if ($range eq "show"){
       # show all subjects
       $range="all";
       # show loop subjects
       $loop=1;
       # show show subjects
       $show=1;
   }

   $range="" if not defined $range;
   my %subjects=();
   my %sub=(); # for return
   my @sub=();
   open (CONF, "<$pro_name/${mode}.cfg") || die "Fehler: $!";
   while (<CONF>){
      s/^ //g; # Leerzeichen am Zeilenangfang entfernen
      if(/^\#/ or 
         /^\s/ 
        ){ # # am Anfang bedeutet Kommentarzeile
          next;
      }
      chomp();
      if (/^LOOP_SUBJECT/){
          if ($loop==1){
              if ( $_=~m/^LOOP_SUBJECT=\"([A-Za-z_-]+)\"/ ){
                  print "   $1 found as LOOP_SUBJECT\n";
                  push @sub, $1;
                  my $short=&translate_to_short($1);
                  $sub{$short}="LOOP_SUBJECT";
	      }
          }
	  next;
      }
      if (/^SHOW_SUBJECT/){
          if ($show==1){
              if ( $_=~m/^SHOW_SUBJECT=\"([A-Za-z_-]+)\"/ ){
                  print "   $1 found as SHOW_SUBJECT\n";
                  push @sub, $1;
                  my $short=&translate_to_short($1);
                  $sub{$short}="SHOW_SUBJECT";
	      }
          }
	  next;
      }
      my ($day,
          $problem,
          $subject,
          $factor,
          $corr_1,
          $group_1,
          $corr_2,
          $group_2)=split(/;/);

      # subjects
      if (not exists $subjects{$subject}){
          $subjects{$subject}=1;
          # add to list if seen once
          if ($mode eq "exam" or $range eq "all"){
             push @sub, $subject;
             $subject=&translate_to_short($subject);
             $sub{$subject}="MAIN";
          }
      } else {
	  my $old=$subjects{$subject};
          my $new=$old+1;
          $subjects{$subject}=$new;
          # add to list if seen twice 
          if ( $mode eq "year" and $old==2 and $range ne "all"){
              push @sub, $subject;
              $subject=&translate_to_short($subject);
              $sub{$subject}="MAIN";
          }
      }
   }

   while (my ($sub,$count) = each %subjects ){
       print "   $sub was seen $count times\n";
   }
   my $string=join(",",@sub);
   print "Subjects: $string\n";
   if ($return eq "array"){
       return @sub;
   } elsif ($return eq "hash"){
       return %sub;
   } else {
       print "ERROR: get_subjects called with wrong option \n";
   }
}




sub set_data_for_subject {
   my ($subject_to_fetch) = @_;
   my %seen=();
   my $seen="";
   @problems=();
   @days=();
   @factors=();

   open (CONF, "$result/${mode}.cfg") || die "Fehler: $!";
   while (<CONF>){
       s/^ //g; # Leerzeichen am Zeilenangfang entfernen
       if(/^\#/ or 
          /^\s/ or 
          /^SHOW_SUBJECT/ or
          /^LOOP_SUBJECT/ 
         ){ # # am Anfang bedeutet Kommentarzeile
         next;
       }
      chomp();
      my ($day,
          $problem,
          $subject,
          $factor,
          $corr_1,
          $group_1,
          $corr_2,
          $group_2)=split(/;/);

      if ($subject eq $subject_to_fetch){
	  $seen = $day.":::".$problem;
          if (exists $seen{$seen}){
	      print "\n\nERROR:\n";
	      print "   I have seen $problem at $day in $subject \n\n";
              exit;
          } else {
              $seen{$seen} = "seen";
              push @problems, $problem;    
              push @days, $day;    
              push @factors, $factor;
          }
      }
   }
   print "problems:", @problems, "\n";
   print "days    :", @days, "\n";
   print "factors:", @factors, "\n";
}







sub latex_preamble {
    open (LATEX, ">$result/results/${mode}/results-$result.tex");

print LATEX ('
\documentclass[fleqn,a4paper,twoside,10pt]{article}
%\usepackage{ifthen}
\usepackage{multicol}
\usepackage{lscape}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{afterpage}
\usepackage{calc}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{ngerman}
\usepackage{fancybox}
\usepackage{marvosym}
\usepackage{fancyhdr}
\usepackage[dvips]{color}
%\usepackage{moreverb}
%\usepackage{twoopt}
%\usepackage{psfrag}
% ams-Befehl square ab jetzt nutzlos, da \square von SIunits neu definiert wird
%\usepackage[cdot,amssymb,thickqspace]{SIunits} 
\usepackage{longtable}
\usepackage{dcolumn}
\usepackage{amsmath}
% uncomment this to the a draft mark accross the page
%\usepackage[german,timestamp,dark]{draftcopy}
\usepackage{lastpage}
% Satzspiegel
\setlength{\voffset}{-25.4mm}
\setlength{\hoffset}{-25.4mm}

% uncomment this to the a draft mark accross the page
%\draftcopyFirstPage{1}

\setlength{\textwidth}{190mm}
\setlength{\topmargin}{0mm}
\setlength{\textheight}{270mm}
\setlength{\headheight}{11mm}
\setlength{\headsep}{2mm}
\setlength{\topskip}{0mm}

\setlength{\footskip}{6.5mm}
\setlength{\parindent}{0mm}

% ohne Rand 
\setlength{\oddsidemargin}{9mm}
\setlength{\evensidemargin}{9mm}

% zentriert
%\setlength{\oddsidemargin}{15mm}
%\setlength{\evensidemargin}{15mm}

\setlength{\fboxsep}{1mm}
\setlength{\fboxrule}{0.35mm}
\setlength{\mathindent}{8mm}

%\newcounter{mypage}
%\setcounter{mypage}{1}

\pagestyle{fancy}

\lhead{}
\chead{}
\rhead{}
\cfoot{\thepage /\pageref{LastPage}}
%\lfoot{\thesection}%
\lfoot{Berufliches Schulzentrum Leonberg}
%\newcounter{showsectionheaders}
%\setcounter{showsectionheaders}{0}

\definecolor{red}{rgb}{1,0,0} 
\definecolor{green}{rgb}{0.15,0.75,0.15}
\definecolor{blue}{rgb}{0.2,0,1}
\definecolor{yellow}{rgb}{0.7,0.7,0.15}
\definecolor{orange}{rgb}{1,0.65,0.15}

');

    print LATEX "\\chead{Ergebnisse von: \\texttt{$result-$mode}}\n";
    print LATEX "\\rfoot{Created by \\texttt{examplix} on \\today}\n";

    if ($final==0){
        print LATEX "% option --final not given\n";
        print LATEX "\\usepackage[german,timestamp,dark]{draftcopy}\n";
        print LATEX "\\draftcopyFirstPage{1}\n";
    } else {
        print LATEX "% option --final given\n";
        print LATEX "%\\usepackage[german,timestamp,dark]{draftcopy}\n";
        print LATEX "%\\draftcopyFirstPage{1}\n";
    }

    print LATEX "\\begin{document}\n";

    if ($mode eq "exam"){
        print LATEX "\\section{Prüfung}\n";
        &print_correction_lists($result);
    }
}



sub print_correction_lists {
    my ($option)=@_;
    my %all_corrections=();
    open (EXAM, "$option/${mode}.cfg") || 
      die "\n   Fehler: $option/${mode}.cfg not found! \n\n";
    while (<EXAM>){
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or 
           /^\s/ or
           /^SHOW_SUBJECT/ or
           /^LOOP_SUBJECT/ 
          ){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        chomp();
        my ($day,
            $problem,
            $subject,
            $factor,
            $corr_1,
            $group_1,
            $corr_2,
            $group_2,
            $corr_3,
            $group_3,
           )=split(/;/);

        # Build the hash
        if($corr_1 ne ""){
         $all_corrections{$day}{$corr_1}{$subject}{"Erstkorrektur"}{$problem}="";
        }
        if($corr_2 ne ""){
         $all_corrections{$day}{$corr_2}{$subject}{"Zweitkorrektur"}{$problem}="";
        }
        if($corr_3 ne ""){
         $all_corrections{$day}{$corr_3}{$subject}{"Drittkorrektur"}{$problem}="";
        }
    }
    foreach my $day (@days){
        my %teachers_table=();
        my @teachers_table=();
        my %subjects_table=();
        my @subjects_table=();
        my $day_long=&translate_to_long($day); 
        print LATEX "\\section{$day_long}\n";
        print "Day $day:\n";
        while (my ($teacher,$v) = each %{ $all_corrections{$day}  } ){
           print "   $teacher  : $v \n";
           # add teacher to hash of teachers
           if (not exists $teachers_table{$teacher}) {
	       $teachers_table{$teacher}="";
           }
           while (my ($subject,$v) = each %{ $all_corrections{$day}{$teacher}  } ){
               print "      $subject  : $v \n";
               # add subject to hash of subjects
               if (not exists $subjects_table{$subject}) {
	           $subjects_table{$subject}="";
               }
           }
        }  
        # create ascibetical list of teachers
        while (my ($teacher,$v) = each %teachers_table ){
	    push @teachers_table, $teacher;
        }
        @teachers_table = sort @teachers_table;
        print "   ascibetical list of teachers:\n";
        foreach my $teacher (@teachers_table){
            print "      $teacher  \n";
        }

        # create ascibetical list of subjects
        while (my ($subject,$v) = each %subjects_table ){
	    push @subjects_table, $subject;
        }
        @subjects_table = sort @subjects_table;
        print "   ascibetical list of subjects:\n";
        foreach my $subject (@subjects_table){
            print "      $subject  \n";
        }

        # create LATEX code
        my $columns=$#subjects_table+2;

        print LATEX "\\begin{center}\n";
        print LATEX "\\begin{tabular}{|l|";
	foreach my $subject (@subjects_table){
            print LATEX "c|";
	}
	print LATEX "l|} \\hline \n";

        # header
        print LATEX "\\rule[-3mm]{0mm}{9mm} & ";
        my $header = join " & ", @subjects_table;
        print LATEX "$header";
        print LATEX " & \\\\ \\hline\\hline \n";

        # the teachers
        foreach my $teacher (@teachers_table){
            print "Lehrer: $teacher \n";
            foreach my $num (@numstrings){
	       my $color="";
               if ($num eq "Erstkorrektur"){
		   $color="red";
      	           print LATEX "\\rule{0mm}{4.5mm}\\textbf{$teacher} ";
               } elsif ($num eq "Zweitkorrektur"){
		   $color="green";
               } elsif ($num eq "Drittkorrektur"){
                   $color="blue";
               }
               foreach my $subject (@subjects_table) {
                  my $problems="";
		  my @problem_list=();
    	          print "   Fach: $subject \n";

                  while (my ($problem,$v) = each
                    %{ $all_corrections{$day}{$teacher}{$subject}{$num}  } ){
                     print "      $problem  : $v \n";
                     push @problem_list, $problem;
                  }
                  @problem_list = sort @problem_list;
		  $problems = join ", ",@problem_list;
                  if ($problems eq ""){
                      $problems="---";
                  }
                  print "$teacher  :  $subject  :  $problems \n"; 
                  print LATEX " & \\textcolor{$color}{$problems} \n"; 
	       }

               if ($num eq "Erstkorrektur"){
                   print LATEX " & \\textcolor{red}{$num} \\\\[1mm] \n";
	       } elsif ($num eq "Zweitkorrektur"){
                   print LATEX " & \\textcolor{green}{$num} \\\\[1mm] \n";
 	       } elsif ($num eq "Drittkorrektur"){
                   print LATEX " & \\textcolor{blue}{$num} \\\\[1mm] \n";
               } else {
                   print LATEX " & $num \\\\[1mm] \n";
               }

            }
            print LATEX "  \\hline \\hline \n";
        }
        print LATEX "\\end{tabular}\n";
        print LATEX "\\end{center}\n";
    }
}


sub latex_headers {
   my ($sub,$num_null)=@_;

   if ($#problems > $max_problems){
      print LATEX "\\newpage \n\n";
      print LATEX "\\begin{landscape}\n\n";
   }
   print LATEX "\\section{$sub}\n\n";
   print LATEX "\\vfill\n\n";
   print LATEX "\\begin{longtable}{|r|l|";
   foreach my $col (@problems){
           print LATEX "c|";
   }
   if ($num_null eq "Erstkorrektur" or $num_null eq "Zweitkorrektur"){
      print LATEX "|c";
   }
   print LATEX "|c||c|}\\caption{$sub--Ergebnisse}\\\\ \\hline \n";


   # Header 1
   print LATEX " & & ";
   foreach my $col (@problems){
      print LATEX "$col & ";
   }
   if ($num_null eq "Erstkorrektur" or $num_null eq "Zweitkorrektur"){
      print LATEX " &";
   }
   print LATEX " & \\\\ \\nopagebreak \n";


   # Header 2
   print LATEX " & & ";
   my $i=0;
   foreach my $day (@days){
       # counting the elements af array
       # fetch problem as rhe $i'th element of problem array
       # from Header 1
       my $corr=$all_correctors{$day}{$problems[$i]}{$sub};
       $i++;
       if ($mode eq "exam"){
           print LATEX "\\footnotesize $day& ";
       } else {
           print LATEX "\\footnotesize $day ($corr)& ";
       }
   }
   if ($num_null eq "Erstkorrektur" or $num_null eq "Zweitkorrektur"){
      print LATEX " &";
   }
   print LATEX " & \\\\ \\nopagebreak\n";


   # Header 3
   print LATEX " & \\textbf{Name} & ";
   foreach my $factor (@factors){
      print LATEX "$factor x & ";
   }
   print LATEX " \$\\Sigma\$ ";
   if ($num_null eq "Erstkorrektur" or $num_null eq "Zweitkorrektur"){
      print LATEX "& \$\\varnothing\$ ";
   }
   print LATEX "&  \$\\varnothing_{ges.}\$ \\\\ \\hline \\hline \n";
   print LATEX "\\endhead \n";
}



sub latex_footer {
   my ($num_null)=@_;
   if ($num_null eq "Erstkorrektur" or $num_null eq "Zweitkorrektur"){
      # do nothing
   } else {
      print LATEX " \\hline ";

      # Footer 1
      print LATEX " \\rule[-2mm]{0mm}{6.3mm}& \$\\varnothing\$& ";
      # Calculate real number of students with this subject
      my $students_num_real=$students_num-$students_num_without_subject;
      foreach my $sum (@sums_class){
          my $ave;
          if ($students_num_real==0){
	      $ave="---";
          } else {
  	      $ave = $sum/$students_num_real;
              $ave = &two_decimal($ave);
              $ave = &dot_to_comma($ave);
	  }
         print LATEX "$ave & ";
      }
      if ($students_num_real==0){
	  $average_class="---";
      } else {
          $average_class = $sum_class/$students_num_real;
          $average_class = &two_decimal($average_class);
          $average_class = &dot_to_comma($average_class);
      }
      print LATEX " & $average_class \\\\ \\hline\n";
   }





}


sub latex_end {
    if (-e "$result/teachers.cfg"){
	open (TEACHERS, "<$result/teachers.cfg");
        print LATEX "\\section{Korrigierende Lehrer}\n";
        print LATEX "\n\\bigskip\n\n";
        print LATEX "\n\\begin{center}\n\n";
        print LATEX "\\begin{tabular}{|c|lcl|} \\hline\n";
        print LATEX "\\rule{0mm}{6mm}\\large Kürzel&\\large Name&&\\large Unterschrift\\\\[1mm] \\hline\\hline\n";
        print LATEX "&&&\\\\[4mm]\n";

        while (<TEACHERS>){
            chomp();
	    my ($short,$name)=split(/::/);
            if (exists $teachers_seen{$short}){
                print LATEX "\\large\\textbf{$short} & ",
                            "\\large\\textbf{$name} & : & ",
                            "\\rule[-2mm]{100mm}{0.3mm}\\hspace{5mm} \\\\[8mm]\n";
	    }
        }
        print LATEX "\\hline\n\\end{tabular}\n\n";
        print LATEX "\n\\end{center}\n\n";

    }

    print LATEX "\\end{document}\n";
    close (LATEX);
}




sub compile_latex {
    my $result_path = "$result/results/${mode}";
    system("cd $result_path; latex results-${result}.tex");
    system("cd $result_path; latex results-${result}.tex");
    system("cd $result_path; latex results-${result}.tex");
    system("cd $result_path; dvips results-${result}.dvi");
    system("cd $result_path; ps2pdf results-${result}.ps");
    system("cd $result_path; kghostview results-${result}.ps");
}




sub one_decimal {
    my ($float) = @_;
    my $one_dec = int(10*$float)/10;
    #$one_dec =~ s/\./,/;
    return $one_dec;
}


sub two_decimal {
    my ($float) = @_;
    my $two_dec = int(100*$float)/100;
    #$two_dec =~ s/\./,/;
    return $two_dec;
}



sub final_mark {
    my ($mark) = @_;
    my $final_mark;
    if ($mark < 1.5){
       $final_mark="1";
   } elsif ($mark < 2.5){
       $final_mark="2";
   } elsif ($mark < 3.5){
       $final_mark="3";
   } elsif ($mark < 4.5){
       $final_mark="4";
   } elsif ($mark < 5.5){
       $final_mark="5";
   } else {
       $final_mark="6";
   }
#    my $mark = int(10*$mark)/10;
#    my $final_mark = sprintf("%.0f", $mark);

    return $final_mark;
}



sub get_result_quick {
    my ($student,$corrector,$subject,$num,$day,$problem) = @_;
    print "Student:   $student \n";
    print "Corrector: $corrector \n";
    print "Subject:   $subject \n";
    print "Num:       $num \n";
    print "Day:       $day \n";
    print "Problem:   $problem \n";
    my $mark=$all_marks{$student}{$corrector}{$subject}{$num}{$day}{$problem};
    # take care, that $mark contains decimal with dot
    # -200: not found
    # -100: empty
    $mark=-200 if not defined $mark; 
    $mark =~ s/,/\./;
    return ($day,$problem,$corrector,$mark);
}


sub get_result_slow {
    my ($student,$corrector,$subject,$num,$day,$problem) = @_;
    my $file=$corrector."_".$subject."_".$num."_".$day."_all.xls";
    print "      Looking in $file \n";
    my $path = "$result/collect/$file";
    my $row;
    my $column;
    my $mark;

    if (not -e $path){
	print "$path is missing \n";
         return ("---","---","---",0);
    }

    my $oBook = Spreadsheet::ParseExcel::Workbook->Parse("$path");
    my($iR, $iC, $oWkS, $oWkC);



          foreach my $oWkS (@{$oBook->{Worksheet}}) {
#    $oWkS->{Name} = "Korrekturergebnis";
              print "--------- SHEET:", $oWkS->{Name}, "\n";
               
              $iC=0;
              for(my $iR = 4;
                  defined $oWkS->{MaxRow} && $iR <= $oWkS->{MaxRow} ; $iR++) {
                   $oWkC = $oWkS->{Cells}[$iR][$iC];
                   #print "( $iR , $iC ) =>", $oWkC->Value, "\n" if($oWkC);
                   if ($oWkC->Value eq $student){
                      #print "ROW:   ($iR,$iC) =>",$oWkC->Value,"\n" if($oWkC);
                      $row=$iR;       
                   }
	       }
                   #look for the correct value
                   for(my $iC = $oWkS->{MinCol} ;
                        defined $oWkS->{MaxCol} && $iC <= $oWkS->{MaxCol} ; $iC++) {
                       $oWkC = $oWkS->{Cells}[3][$iC];

                       if ($oWkC){
                          if  ($oWkC->Value eq $problem){
                            #print "COLUMN:(3,$iC) =>",$oWkC->Value,"\n" if($oWkC); 
                            $column=$iC;       
		          }
                       }

                   }
               $oWkC = $oWkS->{Cells}[$row][$column];
               print "RESULT:($row,$column) =>", $oWkC->Value, "\n" if($oWkC);
               $mark=$oWkC->Value;
          }

    # take care, that $mark contains decimal with dot
    $mark =~ s/,/\./;
    return ($day,$problem,$corrector,$mark);
}




sub create_xls_reg_mark_file {
    my $teacher="class-teacher";
    my $file="";
    if ($exam==1){
        $file="Anmeldenoten_all.xls";
    } else {
        $file="override_all.xls";
    }
    my @problems = &get_loop_subjects();
    my $path_to_create=$tasks.'/tasks'."/${mode}/".$teacher;
    my $filepath=$tasks.'/tasks'."/${mode}/".$teacher.'/'.$file;

    print "Creating $filepath \n";

    system("mkdir -p $path_to_create");
    my $excel = new Spreadsheet::WriteExcel( "$filepath" );
    $excel->set_custom_color(40, 238,  160,  111  );

    my $sheet  = $excel -> addworksheet("Anmeldenoten");
    $sheet->protect('examplix');
    $sheet->set_column('A:A',  22);
#    $sheet->set_column('B:B',  18);

    my $color="grey";
    $excel->set_custom_color(40, 50,  90,  120  );
    $color="blue";
    my $numstring="";
    my $day="";
    my $subject="Fach";
    my $row=1;
    my $column=2;
    my $format = $excel->add_format();
    $format->set_align('left');
    $format->set_bg_color('grey');
    $format->set_border(1);

    my $format_red = $excel->add_format();
    $format_red->set_align('center');
    $format_red->set_bg_color($color);
    $format_red->set_border(1);

    # unlocked to add data
    my $format_empty = $excel->add_format(locked => 0);
    $format_empty->set_border(1);
    $format_empty->set_bg_color(40);

    # inserting the students
    $row=4;
    foreach my $student (@students){
       $sheet -> write( $row, 0, $student, $format );
       $row++;
    }

    # inserting the header
    $sheet -> write( 0, 0, $teacher, $format_red );
    $sheet -> write( 1, 0, $tasks, $format_red );
    $column=1;

    foreach my $subject (@problems){
      my $subject_short=&translate_to_short($subject);
       if ($numstring eq "Halbjahr" or $numstring eq "Schuljahr") {
          $day=$day."(".$teacher.")";
       }
       $sheet -> write( 3, $column, $subject_short, $format_red );
       $sheet -> write( 2, $column, $day, $format_red );
       $sheet -> write( 1, $column, "", $format_red );
       $sheet -> write( 0, $column, $numstring, $format_red );
       my $i;
       for ($i = 1; $i <= $#students+1; $i++) { 
          $sheet -> write( $i+3, $column, "", $format_empty );
       }
       $column++;
    }
    $excel -> close();

}




sub create_xls_file {
    my ($file,$prob) = @_;
    my @problems = split(/;/,$prob);
    my ($teacher,$subject,$numstring,$day)=split(/_/,$file);
    my $path_to_create=$tasks.'/tasks'."/${mode}/".$teacher;
    my $filepath=$tasks.'/tasks'."/${mode}/".$teacher.'/'.$file;

    system("mkdir -p $path_to_create");
    my $excel = new Spreadsheet::WriteExcel( "$filepath" );
    $excel->set_custom_color(40, 238,  160,  111  );

    my $sheet  = $excel -> addworksheet("Korrekturergebnis");
    $sheet->protect('examplix');
    $sheet->set_column('A:A',  22);
    $sheet->set_column('B:B',  18);
    $sheet->set_column('C:C',  18);
    $sheet->set_column('D:D',  18);
    $sheet->set_column('E:E',  18);
    $sheet->set_column('F:F',  18);
    $sheet->set_column('G:G',  18);
    $sheet->set_column('H:H',  18);
    $sheet->set_column('I:I',  18);
    $sheet->set_column('J:J',  18);
    $sheet->set_column('K:K',  18);
    $sheet->set_column('L:L',  18);
    $sheet->set_column('M:M',  18);
 
   # numstring erscheint in B1,C1,...
    my $color="grey";
    if ($numstring eq "Erstkorrektur"){
       $excel->set_custom_color(40, 236,  155,  155  );
       $color="red";
       $numstring="Erst.";
    } elsif ($numstring eq "Zweitkorrektur") {
       $excel->set_custom_color(40, 135,  200,  135  );
       $color="green";
       $numstring="Zweit.";
    } elsif ($numstring eq "Drittkorrektur") {
       $excel->set_custom_color(40, 50,  90,  120  );
       $color="blue";
       $numstring="Dritt.";
    } elsif ($numstring eq "Halbjahr") {
       $excel->set_custom_color(40, 255,  255,  153  );
       $color="yellow";
       $numstring="Halbjahr";
       $sheet->set_column('B:B',  18);
    } elsif ($numstring eq "Schuljahr") {
       $excel->set_custom_color(40, 255,  204,  153  );
       $color="orange";
       $numstring="Schuljahr";
       $sheet->set_column('B:B',  18);
    }
 
    my $row=1;
    my $column=2;

    my $format = $excel->add_format();
    $format->set_align('left');
    $format->set_bg_color('grey');
    $format->set_border(1);

    my $format_red = $excel->add_format();
    $format_red->set_align('center');
    $format_red->set_bg_color($color);
    $format_red->set_border(1);

    # unlocked to add data
    my $format_empty = $excel->add_format(locked => 0);
    $format_empty->set_border(1);
    $format_empty->set_bg_color(40);

    # inserting the students
    $row=4;
    foreach my $student (@students){
       $sheet -> write( $row, 0, $student, $format );
       $row++;
    }

    # inserting the header
    $sheet -> write( 0, 0, $teacher, $format_red );
    $sheet -> write( 1, 0, $tasks, $format_red );
    $column=1;
    foreach my $pro (@problems){
       if ($numstring eq "Halbjahr" or $numstring eq "Schuljahr") {
          $day=$day."(".$teacher.")";
       }
       $sheet -> write( 3, $column, $pro, $format_red );
       $sheet -> write( 2, $column, $day, $format_red );
       $sheet -> write( 1, $column, $subject, $format_red );
       $sheet -> write( 0, $column, $numstring, $format_red );
       my $i;
       for ($i = 1; $i <= $#students+1; $i++) { 
          $sheet -> write( $i+3, $column, "", $format_empty );
       }
       $column++;
    }
    $excel -> close();
}





sub create_task_hash {
    my ($option) = @_;
    my $tmp="";
    my $new_1="";
    my $new_2="";
    my $new_3="";
    my %filename=();
   
    open (EXAM, "$option/${mode}.cfg") || 
      die "\n   Fehler: $option/${mode}.cfg not found! \n\n";
    while (<EXAM>){
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or 
           /^\s/ or
           /^SHOW_SUBJECT/ or
           /^LOOP_SUBJECT/ 
          ){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        chomp();
        my ($day,
            $problem,
            $subject,
            $factor,
            $corr_1,
            $group_1,
            $corr_2,
            $group_2,
            $corr_3,
            $group_3,
           )=split(/;/);

        if (not exists $teachers_seen{$corr_1}){
            $teachers_seen{$corr_1}="seen";
        }

        if (defined $corr_2){
            if (not exists $teachers_seen{$corr_2}){
                $teachers_seen{$corr_2}="seen";
            }
        } else {
            $corr_2="";
        }

        if (defined $corr_3){
            if (not exists $teachers_seen{$corr_3}){
                $teachers_seen{$corr_3}="seen";
            }
        } else {
            $corr_3="";
        }

        #$corr_2="" if not defined $corr_2;
        #$corr_3="" if not defined$corr_3;
        $group_2="" if not defined $group_2;
        $group_3="" if not defined $group_3;

        my $filename_1="";
        my $filename_2="";
        my $filename_3="";

        if ($group_1 eq "") {
            $group_1="all";
        }
        if ($group_2 eq "") {
            $group_2="all";
        }
        if ($group_3 eq "") {
            $group_3="all";
        }
 
        # Create file names
        my $type_string="";
        if ($year==1){
	    $type_string="Schuljahr";
        } elsif ($midyear==1){
	    $type_string="Halbjahr";
        } else {
	    $type_string="Erstkorrektur";
	}

        $filename_1="$corr_1"."_"."$subject"."_".
                     $type_string."_"."$day"."_"."$group_1".".xls";

        # push 
        if (not exists $filename{$filename_1} ){
	    $filename{$filename_1}="$problem";
        } else {
            $tmp=$filename{$filename_1};
            $new_1=$tmp.";".$problem;
            $filename{$filename_1}="$new_1";
        }


        if ("$corr_2" ne ""){       
           $filename_2="$corr_2"."_"."$subject"."_".
                       "Zweitkorrektur"."_"."$day"."_"."$group_2".".xls";
           if (not exists $filename{$filename_2} ){
	       $filename{$filename_2}="$problem";
           } else {
               $tmp=$filename{$filename_2};
               $new_2=$tmp.";".$problem;
               $filename{$filename_2}="$new_2";
           }
        }

        if ("$corr_3" ne ""){       
           $filename_3="$corr_3"."_"."$subject"."_".
                       "Drittkorrektur"."_"."$day"."_"."$group_3".".xls";
           if (not exists $filename{$filename_3} ){
	       $filename{$filename_3}="$problem";
           } else {
               $tmp=$filename{$filename_3};
               $new_3=$tmp.";".$problem;
               $filename{$filename_3}="$new_3";
           }
        }
    }
    close EXAM;
    return %filename;
}





sub create_exam {
#    my ($exam) = @_;
    print "\n  Creating a new exam $create\n\n";
    system("mkdir $create");
    if ($midyear==1){
       open (EXAM, ">>$create/midyear.cfg")|| die "Fehler: $!";
       print EXAM "#FACH(KURZ);Teilfach;FACH(LANG);FAKTOR;KORR;;;\n";
       close EXAM;
    } elsif ($year==1){
       open (EXAM, ">>$create/year.cfg")|| die "Fehler: $!";
       print EXAM "#FACH(KURZ);Teilfach;FACH(LANG);FAKTOR;KORR;;;\n";
       close EXAM;
    } elsif ($exam==1){
       open (EXAM, ">>$create/exam.cfg")|| die "Fehler: $!";
       print EXAM "#TAG;AUFGABE;FACH;FAKTOR;KORR1;GROUP1;KORR2;GROUP2\n";
       close EXAM;
    }
     system("mkdir $create/tasks");
     system("mkdir $create/collect");
     system("mkdir $create/collect/midyear");
     system("mkdir $create/collect/year");
     system("mkdir $create/collect/exam");
     system("mkdir $create/results");
     system("mkdir $create/results/midyear");
     system("mkdir $create/results/year");
     system("mkdir $create/results/exam");
}




sub  check_options{
   my ($parse_ergebnis) = @_;
   if (not $parse_ergebnis==1){
      my @list = split(/\//,$0);
      my $scriptname = pop @list;
      print "\nYou have made a mistake, when specifying options.\n"; 
      print "See error message above. \n\n";
      print "... $scriptname is terminating.\n\n";
      exit;
   } else {
      print "All options  were recognized.\n";
   }

}


sub get_students {
    my ($kind)=@_;
    my @users=();
    my $user;
    my $file=$kind."/students.cfg";

    print "Opening $file to fetch students ...\n";
    open (USERS, "<$file")  || die "Fehler: $file not found!";
    while (<USERS>){
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        $user=$_;
        chomp($user);
        push @users, $user;
    }
    close USERS;
    return @users;
}



sub translate_to_long {
    my ($short)=@_;
    my $long="";
    if (exists $translate_key_short{$short}){
        $long=$translate_key_short{$short};
    } else {
        $long=$short;
    }
    return $long;
}

sub translate_to_short {
    my ($long)=@_;
    my $short="";
    if (exists $translate_key_long{$long}) {
        $short=$translate_key_long{$long};
    } else {
        $short=$long;
    }
    return $short;
}

sub get_translation {
    # open translate.cfg and read it into hashes
    my $path="";
    if ($result ne ""){
        $path=$result;
    } elsif ($tasks ne ""){
        $path=$tasks;
    } elsif ($create ne ""){
        $path=$create;
    }
    if (not -e "$path/translate.cfg"){
        print "WARNING: No translation file $path/translate.cfg found\n";
        return 0;
    }    
    print "Opening $path/translate.cfg to fetch translations ...\n";
    open (TRANSLATE, "$path/translate.cfg") || 
        die "Fehler: $path/translate.cfg not found.\n";
    while (<TRANSLATE>){
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
               next;
            }
	    chomp();
            my ($short,
                $long
               )=split(/::/);
            $translate_key_short{$short}=$long;        
            $translate_key_long{$long}=$short;        
    }
}


sub get_correction_numstrings {
    # decide if 
    # Erstkorrektur
    # Erstkorrektur, Zweitkorrektur
    # Erstkorrektur, Zweitkorrektur, Drittkorrektur
    my $level_1=0;
    my $level_2=0;
    my $level_3=0;
    my $path="";
    if ($result ne ""){
        $path=$result;
    } elsif ($tasks ne ""){
        $path=$tasks;
    } elsif ($create ne ""){
        $path=$create;
    }
    if (not -e "$path/${mode}.cfg"){
        print "WARNING: No file $path/${mode}.cfg found\n";
        return 0;
    }    
    print "Opening $path/${mode}.cfg to fetch correction level ...\n";
    open (CORR, "$path/${mode}.cfg") || 
        die "Fehler: $path/${mode}.cfg not found.\n";
    while (<CORR>){
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/ or 
               /^\s/ or
               /^SHOW_SUBJECT/ or
               /^LOOP_SUBJECT/ 
              ){ # # am Anfang bedeutet Kommentarzeile
               next;
            }
	    chomp();
            my ($day,
                $problem,
                $subject,
                $factor,
                $corr_1,
                $group_1,
                $corr_2,
                $group_2,
                $corr_3,
                $group_3)=split(/;/);

            if (defined $corr_3){
		if ($corr_3 ne ""){
                    $level_3=1;
                }
            }
            if (defined $corr_2){
		if ($corr_2 ne ""){
                    $level_2=1;
                }
            }
            if (defined $corr_1){
		if ($corr_1 ne ""){
                    $level_1=1;
                }
            }
    }
            if ($level_3==1){
		return("Erstkorrektur","Zweitkorrektur","Drittkorrektur");
            }           
            if ($level_2==1){
		return("Erstkorrektur","Zweitkorrektur");
            }           
            if ($level_1==1){
		return("Erstkorrektur");
            }   
            return 0;        
}
