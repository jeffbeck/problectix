#!/usr/bin/perl -w
# This Script (examplix) was created by Rüdiger Beck
# It is released under the GPL Version 2 or higher
# For Bugs send mail to:
# jeffbeck@web.de

# Bibliotheken
use strict;
use Getopt::Long;
#use DBI;
use Spreadsheet::WriteExcel;
use Spreadsheet::ParseExcel;



my $create="";
my $tasks="";
my $result="";
my $help=1;

my %hash=();

my @students=();

my @subjects=();
my @problems=();     
my @days=();     
my @factors=();     

my $max_problems=7;

# todo fetch this ?????????
my @numstrings=("Erstkorrektur","Zweitkorrektur");

# Parsen der Optionen
my $testopt=GetOptions(
           "create|c=s" => \$create,
           "tasks|t=s" => \$tasks,
           "result|r=s" => \$result,
           "help|h" => \$help,
          );

# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);




# --create
if ($create ne "") {
  $help=0;
  #
  if (-e $create){
      print "ERROR: \n",
            "   Exam-Directory $create exists already\n",
            "   I'm doing nothing!\n";
  } else {
     &create_exam($create); 
  }
}




# --tasks
if ($tasks ne "") {
    $help=0;
    if (not -e "$tasks/exam.conf"){
	print "Exam $tasks does not exist. Use option --create\n";
        exit;
    }
    print "Creating the following Task-Files of exam $tasks:\n";
    @students=&get_students($tasks);
    %hash = &create_task_hash();
    while (my ($file,$prob) = each %hash ){
        print "$file with Problems: $prob \n";
        &create_file($file,$prob);
    }
}



# --result
if ($result ne "") {
  $help=0;
  @subjects = &get_subjects();

  &latex_preamble();

  my @stud_res=&get_students($result);

  foreach my $sub (@subjects){
    my $cline_max;
    print "\n################Creating Result of subject $sub ...\n\n";
    &set_data_for_subject($sub);

    &latex_headers($sub);
    my $i=0;
    foreach my $student (@stud_res){
      print "##########  Working on student $student ... ##########\n";
      my $average_1=0;
      my $average_1_format="";
      my $average_2=0;
      my $average_2_format="";
      my $missing_1=0;
      my $missing_2=0;
      # increase student counter
      $i++;
      my ($last,$first)=split(/,/,$student);

      foreach my $num (@numstrings){
         print " ### $num ...\n";
         my $sum=0;
         my $divisor=0;
         my $all_average=0;

         my $line="";
         if ($num eq "Erstkorrektur"){
            $line="\\textbf{$i} & \\textbf{".$last.",} & ";
	 } else {
            $line="  & \\textbf{".$first."} & ";
         }

         open (CONF, "$result/exam.conf") || die "Fehler: $!";
            while (<CONF>){
               s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

#               if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
#                  next;
#               }
               my ($day,
                   $problem,
                   $subject,
                   $factor,
                   $corr_1,
                   $group_1,
                   $corr_2,
                   $group_2)=split(/;/);
               my $corrector;
               if ($num eq "Erstkorrektur"){
		   $corrector=$corr_1;
               } elsif ($num eq "Zweitkorrektur"){
		   $corrector=$corr_2;
               }              

               if ($subject eq $sub) {
                  print "    Fetching data for $problem ...\n";
                  my @result = &get_result($student,
                                           $corrector,
                                           $subject,
                                           $num,
                                           $day,
                                           $problem);
                  print "      * $result[0] $problem of $student corrected",
                        " by $result[2] is $result[3] \n";
                  # make a copy of result
                  # result[3] is used to calculate average, ...
                  # result_format is used as a string to print

                  my $result_format=&format($result[3]);

#                  my $result_format=$result[3];
#                  $result_format =~ s/\./,/;
#                  if (not $result_format =~ m/,/){
#                     $result_format = $result_format.",0"
#                  }
                  if ($num eq "Erstkorrektur"){
                      if ($result[3] eq ""){
                         $line = $line."   \\colorbox{red}{---} &";
                         $missing_1=1;
                      } elsif ($result[3]==0) {
                         $line = $line."   \\colorbox{red}{NF} &";
                         $missing_1=1;
                      } else {                     
                         $line = $line."   \\textcolor{red}{".$result_format."} &";
		      }
                  } elsif ($num eq "Zweitkorrektur"){
                      if ($result[3] eq ""){
                         $line = $line."   \\colorbox{green}{---} &";
                         $missing_2=1;
                      } elsif ($result[3]==0) {
                         $line = $line."   \\colorbox{green}{NF} &";
                         $missing_2=1;
                      } else {                     
                         $line = $line."   \\textcolor{green}{".$result_format."} &";
		      }
                  }    
                  $sum = $sum + $result[3]*$factor;
		  $divisor = $divisor + $factor;
	       }
	    }
	    $cline_max=$#problems+4;
            if ($num eq "Erstkorrektur"){
                $average_1 = $sum / $divisor;
                $average_1 = &one_decimal($average_1);
                $average_1_format = &format($average_1);
                $line = $line." \\textcolor{red}{".$sum."}";

                if ($missing_1==1){
                    $line = $line." & \\colorbox{red}{---} &"; 
                } else {
                    $line = $line." & \\textcolor{red}{".$average_1_format."} &"; 
	        }

#                $line = $line."\\\\\\cline*{2-${cline_max}} \n";
#                $line = $line."\\\\*\\cline{2-${cline_max}} \n";
# makes no pagebreak
                 $line = $line."\\\\* \n";
            } elsif ($num eq "Zweitkorrektur"){
                $average_2 = $sum / $divisor;
                $average_2 = &one_decimal($average_2);
                $average_2_format = &format($average_2);
                $line = $line." \\textcolor{green}{".$sum."}";
                if ($missing_2==1){
                   $line = $line." & \\colorbox{green}{---} &"; 
	        } else {
                   $line = $line." & \\textcolor{green}{".$average_2_format."} &"; 
	        }

                $all_average = 0.5*($average_1 + $average_2 );
                $all_average = &one_decimal($all_average);
                $all_average = &format($all_average);
                if ($missing_1==0 and $missing_2==0){
                   $line = $line." \\LARGE \\textbf{".$all_average."}"; 
	        } else {
                   $line = $line." \\LARGE \\textbf{---}"; 
	        }
                $line = $line."\\\\ \\hline\\hline\\pagebreak[3]\n\n";
            }              
            print LATEX $line;
      }
    }
    print LATEX "\\end{longtable}\n";
    if ($#problems > $max_problems){
       print LATEX "\\end{landscape}\n";
    }
  }
  &latex_end();
  &compile_latex();
}





# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
examplix (EXAMs Per LInux/uniX) is a tool to divide the correction of a larger exam into smaller chunks for a number of people and put together these chunks and calsulate a mark.  

Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info
  -c  / --create examname
  -t  / --tasks examname
  -r  / --result examname

Please see the examplix(1) man pages for full documentation
');
   print "\n";
   exit;
}






############################################################
# SUB
############################################################

sub format {
    my ($number) = @_;
    $number =~ s/\./,/;
    if (not $number =~ m/,/){
       $number = $number.",0"
    }
    return $number;
}


sub get_subjects {
   my %subjects=();
   my @sub=();
   open (CONF, "$result/exam.conf") || die "Fehler: $!";
   while (<CONF>){
      s/^ //g; # Leerzeichen am Zeilenangfang entfernen

        if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

#      if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
#         next;
#      }
      my ($day,
          $problem,
          $subject,
          $factor,
          $corr_1,
          $group_1,
          $corr_2,
          $group_2)=split(/;/);

      # subjects
      if (not exists $subjects{$subject}){
          $subjects{$subject}="";
          push @sub, $subject;
      }
   }
   print "Subjects:", @sub, "\n";
   return @sub;
}




sub set_data_for_subject {
   my ($subject_to_fetch) = @_;
   my %seen=();
   my $seen="";
   @problems=();
   @days=();
   @factors=();

   open (CONF, "$result/exam.conf") || die "Fehler: $!";
   while (<CONF>){
      s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

#      if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
#         next;
#      }
      
      my ($day,
          $problem,
          $subject,
          $factor,
          $corr_1,
          $group_1,
          $corr_2,
          $group_2)=split(/;/);

      if ($subject eq $subject_to_fetch){
	  $seen = $day.":::".$problem;
          if (exists $seen{$seen}){
	      print "\n\nERROR\n";
	      print "   I have seen $problem at $day in $subject \\n";
              exit;
          } else {
              $seen{$seen} = "seen";
              push @problems, $problem;    
              push @days, $day;    
              push @factors, $factor;
          }
      }
   }
   print "problems:", @problems, "\n";
   print "days    :", @days, "\n";
   print "factors:", @factors, "\n";
}







sub latex_preamble {
    open (LATEX, ">$result/results/results-$result.tex");

print LATEX ('
\documentclass[fleqn,a4paper,twoside,10pt]{article}
%\usepackage{ifthen}
\usepackage{multicol}
\usepackage{lscape}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{afterpage}
\usepackage{calc}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{ngerman}
\usepackage{fancybox}
\usepackage{marvosym}
\usepackage{fancyhdr}
\usepackage[dvips]{color}
%\usepackage{moreverb}
%\usepackage{twoopt}
%\usepackage{psfrag}
% ams-Befehl square ab jetzt nutzlos, da \square von SIunits neu definiert wird
%\usepackage[cdot,amssymb,thickqspace]{SIunits} 
\usepackage{longtable}
\usepackage{dcolumn}
\usepackage{amsmath}
% uncomment this to the a draft mark accross the page
%\usepackage[german,timestamp,dark]{draftcopy}
\usepackage{lastpage}
% Satzspiegel
\setlength{\voffset}{-25.4mm}
\setlength{\hoffset}{-25.4mm}

% uncomment this to the a draft mark accross the page
%\draftcopyFirstPage{1}

\setlength{\textwidth}{190mm}
\setlength{\topmargin}{0mm}
\setlength{\textheight}{270mm}
\setlength{\headheight}{11mm}
\setlength{\headsep}{2mm}
\setlength{\topskip}{0mm}

\setlength{\footskip}{6.5mm}
\setlength{\parindent}{0mm}

% ohne Rand 
\setlength{\oddsidemargin}{9mm}
\setlength{\evensidemargin}{9mm}

% zentriert
%\setlength{\oddsidemargin}{15mm}
%\setlength{\evensidemargin}{15mm}

\setlength{\fboxsep}{1mm}
\setlength{\fboxrule}{0.35mm}
\setlength{\mathindent}{8mm}

%\newcounter{mypage}
%\setcounter{mypage}{1}

\pagestyle{fancy}

\lhead{}
\chead{}
\rhead{}
\cfoot{\thepage /\pageref{LastPage}}
%\lfoot{\thesection}%
\lfoot{Berufliches Schulzentrum Leonberg}
%\newcounter{showsectionheaders}
%\setcounter{showsectionheaders}{0}

\definecolor{red}{rgb}{1,0,0} 
\definecolor{green}{rgb}{0.15,0.75,0.15}
\definecolor{blue}{rgb}{0.2,0,1}

');

    print LATEX "\\chead{Ergebnisse von: \\texttt{$result}}\n";
    print LATEX "\\rfoot{Created by \\texttt{examplix}}\n";
    print LATEX "\\begin{document}\n";
#    print LATEX "\\afterpage{\\clearpage}\n";
}





sub latex_headers {
   my ($sub)=@_;

   if ($#problems > $max_problems){
      print LATEX "\\newpage \n\n";
      print LATEX "\\begin{landscape}\n\n";
   }
   print LATEX "\\section{$sub}\n\n";
   print LATEX "\\vfill\n\n";
   print LATEX "\\begin{longtable}{|r|l|";
   foreach my $col (@problems){
           print LATEX "c|";
   }

   print LATEX "|c|c||c|}\\caption{$sub--Ergebnisse}\\\\ \\hline \n";

   # Header 1
   print LATEX " & & ";
   foreach my $col (@problems){
      print LATEX "$col & ";
   }
   print LATEX " & & \\\\ \\nopagebreak \n";

   # Header 2
   print LATEX " & & ";
   foreach my $day (@days){
      print LATEX "\\footnotesize $day & ";
   }
   print LATEX " & & \\\\ \\nopagebreak\n";

   # Header 3
   print LATEX " & \\textbf{Name} & ";
   foreach my $factor (@factors){
      print LATEX "$factor x & ";
   }
   print LATEX " \$\\Sigma\$ & \$\\varnothing\$  & ",
               " \$\\varnothing_{ges.}\$ \\\\ \\hline \\hline \n";
   print LATEX "\\endhead \n";
}





sub latex_end {
    if (-e "$result/config/teachers.txt"){
	open (TEACHERS, "<$result/config/teachers.txt");
        print LATEX "\\section{Korrigierende Lehrer}\n";
        print LATEX "\n\\bigskip\n\n";
        print LATEX "\n\\begin{center}\n\n";
        print LATEX "\\begin{tabular}{|c|lcl|} \\hline\n";
        print LATEX "\\rule{0mm}{6mm}\\large Kürzel&\\large Name&&\\large Unterschrift\\\\[1mm] \\hline\\hline\n";
        print LATEX "&&&\\\\[4mm]\n";

        while (<TEACHERS>){
            chomp();
	    my ($short,$name)=split(/::/);
            print LATEX "\\large\\textbf{$short} & ",
                        "\\large\\textbf{$name} & : & ",
                        "\\rule[-2mm]{100mm}{0.3mm}\\hspace{5mm} \\\\[8mm]\n";
        }
        print LATEX "\\hline\n\\end{tabular}\n\n";
        print LATEX "\n\\end{center}\n\n";


    }
    print LATEX "\\end{document}\n";
    close (LATEX);
}




sub compile_latex {
    my $result_path = "$result/results";
    system("cd $result_path; latex results-${result}.tex");
    system("cd $result_path; latex results-${result}.tex");
    system("cd $result_path; latex results-${result}.tex");
    system("cd $result_path; dvips results-${result}.dvi");
    system("cd $result_path; kghostview results-${result}.ps");
}




sub one_decimal {
    my ($float) = @_;
    my $one_dec = int(10*$float)/10;
    $one_dec =~ s/\./,/;
    return $one_dec;
}



sub get_result {
    my ($student,$corrector,$subject,$num,$day,$problem) = @_;
    my $file=$corrector."_".$subject."_".$num."_".$day."_all.xls";
    print "      Looking in $file \n";
    my $path = "$result/collect/$file";
    my $row;
    my $column;
    my $mark;

    if (not -e $path){
	print "$path is missing \n";
         return ("---","---","---",0);
    }

    my $oBook = Spreadsheet::ParseExcel::Workbook->Parse("$path");
    my($iR, $iC, $oWkS, $oWkC);



          foreach my $oWkS (@{$oBook->{Worksheet}}) {
#    $oWkS->{Name} = "Korrekturergebnis";
              print "--------- SHEET:", $oWkS->{Name}, "\n";
               
              $iC=0;
              for(my $iR = 4;
                  defined $oWkS->{MaxRow} && $iR <= $oWkS->{MaxRow} ; $iR++) {
                   $oWkC = $oWkS->{Cells}[$iR][$iC];
                   #print "( $iR , $iC ) =>", $oWkC->Value, "\n" if($oWkC);
                   if ($oWkC->Value eq $student){
                      #print "ROW:   ($iR,$iC) =>",$oWkC->Value,"\n" if($oWkC);
                      $row=$iR;       
                   }
	       }
                   #look for the correct value
                   for(my $iC = $oWkS->{MinCol} ;
                        defined $oWkS->{MaxCol} && $iC <= $oWkS->{MaxCol} ; $iC++) {
                       $oWkC = $oWkS->{Cells}[3][$iC];

                       if ($oWkC){
                          if  ($oWkC->Value eq $problem){
                            #print "COLUMN:(3,$iC) =>",$oWkC->Value,"\n" if($oWkC); 
                            $column=$iC;       
		          }
                       }

                   }
               $oWkC = $oWkS->{Cells}[$row][$column];
               print "RESULT:($row,$column) =>", $oWkC->Value, "\n" if($oWkC);
               $mark=$oWkC->Value;
          }
    return ($day,$problem,$corrector,$mark);
}









sub create_file {
    my ($file,$prob) = @_;
    my @problems = split(/;/,$prob);
    my ($teacher,$subject,$numstring,$day)=split(/_/,$file);
    my $path_to_create=$tasks.'/tasks/'.$teacher."/todo";
    my $path2_to_create=$tasks.'/tasks/'.$teacher."/result";
    my $filepath=$tasks.'/tasks/'.$teacher.'/todo/'.$file;

    system("mkdir -p $path_to_create");
    system("mkdir -p $path2_to_create");
    my $excel = new Spreadsheet::WriteExcel( "$filepath" );
    $excel->set_custom_color(40, 238,  160,  111  );

    my $color="grey";
    if ($numstring eq "Erstkorrektur"){
       $excel->set_custom_color(40, 236,  155,  155  );
       $color="red";
       $numstring="Erst."
    } elsif ($numstring eq "Zweitkorrektur") {
       $excel->set_custom_color(40, 135,  200,  135  );
       $color="green";
       $numstring="Zweit."
    }

    my $sheet  = $excel -> addworksheet("Korrekturergebnis");
    $sheet->protect('examplix');
    $sheet->set_column(0, 0,  20);

    my $row=1;
    my $column=2;

    my $format = $excel->add_format();
    $format->set_align('left');
    $format->set_bg_color('grey');
    $format->set_border(1);

    my $format_red = $excel->add_format();
    $format_red->set_align('center');
    $format_red->set_bg_color($color);
    $format_red->set_border(1);

    # unlocked to add data
    my $format_empty = $excel->add_format(locked => 0);
    $format_empty->set_border(1);
    $format_empty->set_bg_color(40);

    # inserting the students
    $row=4;
    foreach my $student (@students){
       $sheet -> write( $row, 0, $student, $format );
       $row++;
    }

    # inserting the header
    $sheet -> write( 0, 0, $teacher, $format_red );
    $sheet -> write( 1, 0, $tasks, $format_red );
    $column=1;
    foreach my $pro (@problems){
       $sheet -> write( 3, $column, $pro, $format_red );
       $sheet -> write( 2, $column, $day, $format_red );
       $sheet -> write( 1, $column, $subject, $format_red );
       $sheet -> write( 0, $column, $numstring, $format_red );
       my $i;
       for ($i = 1; $i <= $#students+1; $i++) { 
          $sheet -> write( $i+3, $column, "", $format_empty );
       }
       $column++;
    }
    $excel -> close();
}





sub create_task_hash {
    my $tmp="";
    my $new_1="";
    my $new_2="";
    my %filename=();
    open (EXAM, "$tasks/exam.conf") || die "Fehler: $!";
    while (<EXAM>){
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

#        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
#           next;
#        } 
        chomp();
        my ($day,
            $problem,
            $subject,
            $factor,
            $corr_1,
            $group_1,
            $corr_2,
            $group_2)=split(/;/);

        if ($group_1 eq "") {
            $group_1="all";
        }
        if ($group_2 eq "") {
            $group_2="all";
        }
        my $filename_1="$corr_1"."_"."$subject"."_".
                       "Erstkorrektur"."_"."$day"."_"."$group_1".".xls";
        my $filename_2="$corr_2"."_"."$subject"."_".
                       "Zweitkorrektur"."_"."$day"."_"."$group_1".".xls";
        if (not exists $filename{$filename_1} ){
	    $filename{$filename_1}="$problem";
        } else {
            $tmp=$filename{$filename_1};
            $new_1=$tmp.";".$problem;
            $filename{$filename_1}="$new_1";
        }
        if (not exists $filename{$filename_2} ){
	    $filename{$filename_2}="$problem";
        } else {
            $tmp=$filename{$filename_2};
            $new_2=$tmp.";".$problem;
            $filename{$filename_2}="$new_2";
        }
    }
    close EXAM;
    return %filename;
}





sub create_exam {
    my ($exam) = @_;
     print " Creating a new exam $create\n";
     system("mkdir $create");
     system("mkdir $create/config");
     system("touch $create/exam.conf");
     open (EXAM, ">>$create/exam.conf")|| die "Fehler: $!";
     print EXAM "#TAG;AUFGABE;FACH;FAKTOR;KORR1;GROUP1;KORR2;GROUP2\n";
     close EXAM;
     system("mkdir $create/tasks");
     system("mkdir $create/collect");
     system("mkdir $create/results");
}




sub  check_options{
   my ($parse_ergebnis) = @_;
   if (not $parse_ergebnis==1){
      my @list = split(/\//,$0);
      my $scriptname = pop @list;
      print "\nYou have made a mistake, when specifying options.\n"; 
      print "See error message above. \n\n";
      print "... $scriptname is terminating.\n\n";
      exit;
   } else {
      print "All options  were recognized.\n";
   }

}


sub get_students {
    my ($kind)=@_;
    my @users=();
    my $user;
    my $file=$kind.'/config/'."users.txt";

    print "Opening $file to fetch students ...\n";
    open (USERS, "<$file")  || die "Fehler: $!";
    while (<USERS>){
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/ or /^\s/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        $user=$_;
        chomp($user);
        push @users, $user;
    }
    close USERS;
    return @users;
}
