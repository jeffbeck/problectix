#!/usr/bin/perl
# Dieses Script (jefflatex) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de

# Information about calling this script from within emacs
# can be found in the README (Debian: /usr/share/doc/problectix/README) 

use strict;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Spreadsheet::Read;
use File::Copy;
use File::Basename qw( basename
                       dirname
                       fileparse
                     );       
my $spsh;
my $spreadsheet_file="";
my %spsh_commands=(
                   2 , '\ab{',
                   3 , '\abc{',
                   4 , '\abcd{',
                   5 , '\abcde{',
                   6 , '\abcdef{',
                   7 , '\abcdefg{',
                   8 , '\abcdefgh{',
                   );

my %group_commands=(
                   1 , '\gruppea',
                   2 , '\gruppeb',
                   3 , '\gruppec',
                   4 , '\grupped',
                   5 , '\gruppee',
                   6 , '\gruppef',
                   7 , '\gruppeg{',
                   8 , '\gruppeh{',
                   );

my %file_info=();
$file_info{'order'}=0;
$file_info{'alloptions'}=0;
$file_info{'group-commands'}=1; # \ab,...
$file_info{'groups-real'}=1;    # \ab and after spshcells
$file_info{'group-selected'}="";
$file_info{'spreadsheet'}=0;

my $spreadsheet_digits=2;
my $spreadsheet_string=0;

my $found=0;
my @pdf_viewer=();
my @ps_viewer=();
my @png_viewer=();

my $home=$ENV{'HOME'};

# ===========================================================================
# Konfig-Dateien sourcen
# ==========================================================================

# systemweite Konfiguration
my $sys_config = "/etc/problectix/problectix.conf";

# userabhaengige Konfiguration
my $config_dir="$ENV{'HOME'}/.problectix";
my $user_config="$config_dir"."/.problectix";

# Abbruch, falls sysweite config fehlt
if (not -e $sys_config) {
    print "$sys_config does not exist. exiting ...\n\n";
    exit;
} else {
   # werte der sysconfig einlesen
   { package SysConf ; do "$sys_config"}
    @pdf_viewer = @SysConf::pdf_viewer;
    @ps_viewer = @SysConf::ps_viewer;
    @png_viewer = @SysConf::png_viewer;
}

# userweite config sourcen, falls existent
if (-e "$user_config") {
   { package UserConf ; do "$user_config"}
    @pdf_viewer = @UserConf::pdf_viewer;
    @ps_viewer = @UserConf::ps_viewer;
    @png_viewer = @UserConf::png_viewer;
}

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Schalter
my $a5_landscape=0;
my $a5_landscape_repeat=0;

# Variablen für Optionen
my $help=0;
my $pdf=0;
my $png=0;
my $silent_dvips=0;
my $dvips_string="";
my $presentation=0;
my $file ="";
my $noview =0;
my $tex_file="";
my $source_dir="";
my $pngwidth="980";
my $a0_plus=0;
my $a0=0;
my $a1=0;
my $a2=0;
my $a3=0;
my $a5=0;
my $pages="";
my $target_dir_opt="";
my $target_file_opt="";

print "##### jefflatex is parsing Options ...\n";

# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "pdf" => \$pdf,
           "png" => \$png,
           "silent-dvips" => \$silent_dvips,
           "pngwidth=i" => \$pngwidth,
           "presentation" => \$presentation,
           "file|f=s" => \$file,
           "noview|noviewer|no-viewer" => \$noview,
           "a0plus|A0plus" => \$a0_plus,
           "a0|A0" => \$a0,
           "a1|A1" => \$a1,
           "a2|A2" => \$a2,
           "a3|A3" => \$a3,
           "a5|A5" => \$a5,
           "pages=s" => \$pages,
           "target-dir|d=s" => \$target_dir_opt,
           "target-file=s" => \$target_file_opt,
          );


# --help
if ($help==1){
   print "\njefflatex (pronounced jeff-la-tex) compiles (*.tex -> *.ps/*.pdf)",
         " a latex source file and opens an appropriate viewer to",
         " display the resulting *.ps/*.pdf\n";

   # optionen
   print('
Options
  -h  / --help
  --pdf
  --png
  --pngwidth pixelnum
  --presentation
  --file name
  --noview / --noviewer / --no-viewer

Post-Processing Option for PostScript output:
 Resize:
  --a5
  --a3
  --a2
  --a1
  --a0
  --a0plus (max. size for some HP Plotters)
 Page Selection:
  --pages 1,3,7    (selects only page 1,3 and 7)
    The Option is passed on to the psselect command (see man psselect for the full syntax)
 Filename selection (No viewer ist started):
  --taget-file filename.ps 
  --taget-dir ./generated

Please see the jefflatex(1) man page for full documentation
');
   print "\n";
   exit;
}


# --silent-dvips
if ($silent_dvips==1){
    $dvips_string="> /dev/null 2>&1";
    print "HERE\n";
}


# Exit, if no file was given
if ($file eq ""){
    print "No path to a file given  (Use:  -f path/to/a/file.tex)\n";
    exit;
}


# calculate width
my $width=$pngwidth*2-7;

# Calculate the full path (including .tex)
if (-e "$file"){
     # if the file exists
     $tex_file = "$file";
     #$file=~s/.tex$//g;
} else {
     $tex_file = "$file".".tex";
}

# Exit if file doesnt exist
if (not -e "$tex_file"){
    print "Files do not exist, I looked for:\n",
          "   $tex_file\n",
          "   $file\n\n";
    exit;
}


print "$tex_file\n";

# Calculate path, ...
my ($base,$source_dir,$type) = fileparse("$tex_file",".tex");

# convert to absolute paths
# get the absolute path of --dir Directory
chdir "$source_dir" || 
   die "Kann nicht nach $source_dir wechseln";
my $abs_path=`pwd`;
chomp($abs_path);
print "Abs. Path: $abs_path\n";

$tex_file=$abs_path."/".$base.$type;
my $base_file=$abs_path."/".$base;

($base,$source_dir,$type) = fileparse("$tex_file",".tex");


my $tex_temp_file = "$base"."-temp"."$type";
my $anki_temp_file = "$base"."-anki-temp"."$type";
my $anki_txt_file = "$base"."-anki.txt";

my $base_tmp="$base"."-temp";
my $base_anki_tmp="$base"."-anki-temp";

my $ankisimple=0;

print "Path:      $source_dir\n";
print "Base:      $base\n";
print "Type:      $type\n";
print "Temp:      $tex_temp_file\n";




&check_options($testopt);

############################################################
# Start
############################################################




# ist Vorspann voranzusetzten?
print "##### jefflatex is checking type of \n$tex_file\n";
&check_file();
print "   ### Versions      : $file_info{'group-commands'}\n";
print "   ### Filetype      : $file_info{'type'} \n";
print "   ### alloptions    : $file_info{'alloptions'} \n";
print "   ### order         : $file_info{'order'}\n";
print "   ### Group selected: $file_info{'group-selected'}\n";
print "   ### Spreadsheet   : $file_info{'spreadsheet'} ($spreadsheet_file) \n";

print "##### ... checking type of \n$tex_file \n##### is done\n\n";


# Anki Latex Source
if ($file_info{'type'} eq "anki-latex-source"){
    print "Anki Latex Source file detected\n";
    open (ANKITMP, ">$anki_temp_file");
    print "Creating $anki_temp_file\n";
    open (ANKITXT, ">$anki_txt_file");
    print "Creating $anki_txt_file\n";
    print ANKITMP "% generated from ${base}${type}\n";
    open (TEX, $tex_file);
    my $question_de_count=0;
    my $answer_de_count=0;

    # note-id
    my $note_id_count=0;
    my $note_id="";
    # note-date
    my $note_date_count=0;
    my $note_date="";
    # from-version
    my $from_version_count=0;
    my $from_version="";
    # to-version
    my $to_version_count=0;
    my $to_version="";
    # level
    my $note_level_count=0;
    my $note_level="";

    # temporary stuff
    my $tag="";

    # cat
    my $cat_count=0;
    my $cat_string="";
    my @cat_list=();
    # note-end
    my $note_end_count=0;

    # anki_latex_mode
    # 1 between [latex] and [/latex], else 0
    my $anki_latex_mode=0;
    while (<TEX>) {
        if (/^%anki/ or /^%ankisimple/){
            if (/^%ankisimple/){
                print "detected %ankisimple\n";
                $ankisimple=1;
            } else {
                print "detected %anki\n";
            }
            print ANKITMP "% detected $_" ;
            # preamble
            &print_anki_preamble;
            $anki_latex_mode=0;
            # document title
            print ANKITMP "\\textbf{Quelldatei:} \\verb|${base}${type}|\n";
        } elsif (/^%note-id/){
            $note_id_count++;
            print "LINE: $_\n";
            ($tag,$note_id)=split(/=/,$_);
            chomp($note_id);
            $note_id=~s/ //g;
            print "NOTE-ID: >$note_id<\n";
        } elsif (/^%note-date/){
            $note_date_count++;
            print "LINE: $_\n";
            ($tag,$note_date)=split(/=/,$_);
            chomp($note_date);
            $note_date=~s/ //g;
            print "NOTE-DATE: >$note_date<\n";
            print ANKITXT ";$note_date";
        } elsif (/^%from-version/){
            $from_version_count++;
            print "LINE: $_\n";
            ($tag,$from_version)=split(/=/,$_);
            chomp($from_version);
            $from_version=~s/ //g;
            print "FROM-VERSION: >$from_version<\n";
        } elsif (/^%to-version/){
            $to_version_count++;
            print "LINE: $_\n";
            ($tag,$to_version)=split(/=/,$_);
            chomp($to_version);
            $to_version=~s/ //g;
            print "TO-VERSION: >$to_version<\n";
        } elsif (/^%level/){
            $note_level_count++;
            print "LINE: $_\n";
            ($tag,$note_level)=split(/=/,$_);
            chomp($note_level);
            $note_level=~s/ //g;
            print "NOTE-LEVEL: >$note_level<\n";
        } elsif (/^%question-de/ or /^%front/){
            $question_de_count++;
            print "   Card ${question_de_count}: ",
                  "detected %question-de $question_de_count times\n";
            print ANKITMP "\\bigskip\n";
            if (${question_de_count}!=1){
                print ANKITMP "\\end{minipage}\n";
	    }
            print ANKITMP "\\begin{minipage}{\\textwidth}\n";
            print ANKITMP "\\rule{\\textwidth}{0.35mm}\n";
            print ANKITMP "\\smallskip\n\n";
            print ANKITMP "% Card ${question_de_count}: detected $_";
            print ANKITMP "\\begin{minipage}{35mm}\n";
            print ANKITMP "\\textbf{Frage ${question_de_count}}\n\n";
            # Print that always
            print ANKITMP "ID: ${note_id}\n\n";
            print ANKITMP "${note_date}\n\n";
            # Print this only if not empty
            &print_anki_if_not_empty("Ab",${from_version});
            &print_anki_if_not_empty("Bis",${to_version});
            &print_anki_if_not_empty("Level",${note_level});
            &print_anki_if_not_empty("Cat",${cat_string});
            foreach my $cat (@cat_list){
                print ANKITMP "\\hspace{1mm}$cat\n\n";
            }
            print ANKITMP "\\end{minipage}\n";
            print ANKITMP "\\begin{minipage}{135mm}\n";

            print ANKITXT "\n# Card ${question_de_count} ID=$note_id follows:\n";
            print ANKITXT "$note_id".
                          ";$note_date".
                          ";$from_version".
                          ";$to_version".
                          ";$note_level".
                          ";${base}${type}".
                          ";$cat_string".
                          ";[latex]";
            $anki_latex_mode=1;

            # newpage from second appearance on
            #if ($question_de_count > 1){
            #    print ANKITMP "\\newpage\n";
            #}
        } elsif (/^%answer-de/ or /^%back/){
            $answer_de_count++;
            print "   Card ${answer_de_count}: ",
                  "detected %answer-de $answer_de_count times\n";
            # new page for answers (--> two pages for one card)
            #print ANKITMP "\\newpage\n";
            # horizontal line after question (--> one page for one card)
            print ANKITMP "\n\\rule{\\textwidth}{0.2mm}\n\n";
            print ANKITMP "% Card ${answer_de_count}: detected $_";

            print ANKITXT "[/latex];[latex]";
            $anki_latex_mode=1;
        } elsif (/^%cat/){
            $cat_count++;
            print "   Card ${cat_count}: detected %cat\n";
            my ($tmp, @cats)=split(/\s/,$_);
            foreach my $tmp_cat (@cats){
                $tmp_cat=~s/ //g;
                $tmp_cat=~s/_/-/g;
                push @cat_list, $tmp_cat;
            }
            if ($ankisimple==1){
                # end the simple card
                $note_end_count++;
                # remove %note-end
                my $txt=$_;
                $txt=~s/%note-end//;
                chomp($txt);
                &anki_end_card(${note_end_count},${txt});
                $anki_latex_mode=0;
                # empty the cat list for nex note
                @cat_list=();
            }
        } elsif (/^%note-end/){
            $note_end_count++;
            # remove %note-end
            my $txt=$_;
            $txt=~s/%note-end//;
            chomp($txt);
            &anki_end_card(${note_end_count},${txt});
            $anki_latex_mode=0;
            # empty the cat list for nex note
            @cat_list=();
        } elsif (/^%end/){
            print "detected %end\n";
            $anki_latex_mode=0;
            print ANKITMP $_ ;
            # postamble
            &print_anki_postamble;
        } elsif (/^%/){
            # other comment, do nothing
        } else {
            my $tmp = $_;
            # do nothing
            #$tmp=~s///g;
            print ANKITMP $tmp ;

            my $txt = $_;
            # \n --> <br> witch is &lt;br&gt; 
            if ($anki_latex_mode==1){
                # create line break for anki
                $txt=~s/\n/<br>/g;
	    } else {
                $txt=~s/\n//g; # empty line to end commands
            }
            print ANKITXT $txt ;
        }
    }
    close(TEX);
    close(ANKITMP);
    close(ANKITXT);
    print "%question-de: $question_de_count\n";
    print "%answer-de:  $answer_de_count\n";
    #print "%cat:   $cat_count\n";
    print "%note-end:   $note_end_count\n";
    if ($question_de_count==$answer_de_count and $answer_de_count==$note_end_count){
        &compile_tex($base_anki_tmp);
        # start viewer   
        if ($noview==0){
            &viewer($base_anki_tmp.".ps");
        }
    } else {
        print "\nERROR: %question-de (%front), %answer-de(%back) and %note_end",
              " HAVE TO BE USED ON EVERY CARD\n";
    }
    exit;
}


if ($png==1){
    $file_info{'group-commands'}=1;
}



if ($file_info{'spreadsheet'}==1){
   #my $sphs = ReadData ("test.ods");
   $spsh = ReadData ($spreadsheet_file);
}






############################################################
# Datei verändern
############################################################
my @version_line=("\\gruppea\n","\\gruppeb\n","\\gruppec\n","\\grupped\n",
                  "\\gruppee\n","\\gruppef\n","\\gruppeg\n","\\gruppeh\n");
my @version_color=("rosa","lila","rot","orange",
                   "rosa2","lila2","rot2","orange2");
my @version_string=("Gruppe A","Gruppe B","Gruppe C","Gruppe D",
                    "Gruppe E","Gruppe F","Gruppe G","Gruppe H");

my @options=();
if ($png==1){
    @options=("","lsg");
} elsif ($file_info{'alloptions'}==1) {
    @options=("",
              "ka","kalsg",
              "kamulti","kamultilsg",
              "exam","examlsg",
              "arb","arblsg",
              "col","lsg","slsg");
} elsif ( $file_info{'type'} eq "texfile" ) {
    @options=("vorspannexists");
} else {
    @options=("","kamultilsg","kamulti","lsg");
}

print "##### generating $tex_temp_file in $file_info{'group-commands'} versions\n";
open (TEXTEMP, ">$tex_temp_file");

############################################################
# Vorspann voransetzen
############################################################
if ( $file_info{'type'} eq "problemfile" ){
    print "Adding vorspann\n";
    print TEXTEMP '\documentclass[]{teacher}',"\n";
    if ($png==1){
        print TEXTEMP '\special{papersize=210mm,2897mm}',"\n";
        print TEXTEMP '\pagestyle{empty}',"\n";
    }
    print TEXTEMP "\n\n";
    print TEXTEMP "\\begin{document}\n";
    print TEXTEMP "\\sbox{\\dateiname}{$base\\RCSMaster}\n";

    print TEXTEMP '\setcounter{aufgabennummer}{0}',"\n";
    if ($png==1){
        print TEXTEMP '\enlargethispage{2800mm}',"\n";
    }
    print TEXTEMP '\cfoot{}',"\n";
    print TEXTEMP "\n\n";
}

open (TEX, $tex_file);
my $i;
my $index;
# count from 1 to $file_info{'group-commands'}
for ($i = 1; $i <= $file_info{'group-commands'}; $i++) {
    $index=$i-1;
    print"Working on Version $i (Index: $index)...\n";

    foreach my $option (@options){
        $option="all" if $option eq "";
        my $optionstring="";
        if ($option eq "all"){
            $optionstring="[ ]";
	} else {
            $optionstring=$option;
	}
	my $file=$option."-format";

        if ($option ne "vorspannexists"){
            print TEXTEMP '\setcounter{aufgabennummer}{0}',"\n";
            print TEXTEMP "\\input{$file} \n";
            print TEXTEMP "\\bigskip\\par \n";
            print TEXTEMP "\\setlength{\\temp}{\\fboxrule} \n";
            print TEXTEMP "\\setlength{\\fboxrule}{0.75mm}% \n";
            print TEXTEMP "\\framebox[\\textwidth]{\\rule[-2mm]{0mm}{7.5mm}".
                          "\\Large \\bfseries Option: $optionstring}\n";
            # print TEXTEMP "\\setlength{\\fboxrule}{0.3mm} \n";
            print TEXTEMP "\\setlength{\\fboxrule}{\\temp}% \n";

            print TEXTEMP "\\bigskip \\par\n"; 

            print "   Adding Line--l: $version_line[$index]"; 
            print TEXTEMP "$version_line[$index]"; 
            print TEXTEMP "\\chead{\\bfseries \\Large ".
                  "\\textcolor{$version_color[$index]}{$version_string[$index]}}\n";
	}

        open (TEX, $tex_file);
        while (<TEX>) {
            if (/^%/){
                print "Comment: $_";
                next;
            }
            ##################################################
            # group count
            ##################################################
            while (/\\ab{/) {
                &check_groups(2);
                $_=~s/\\ab{/\\zb{/;
            }
            $_=~s/\\zb{/\\ab{/g;

            while (/\\abc{/) {
                &check_groups(3);
                $_=~s/\\abc{/\\zbc{/;
            }
            $_=~s/\\zbc{/\\abc{/g;

            while (/\\abcd{/) {
                &check_groups(4);
                $_=~s/\\abcd{/\\zbcd{/;
            }
            $_=~s/\\zbcd{/\\abcd{/g;

            while (/\\abcde{/) {
                &check_groups(5);
                $_=~s/\\abcde{/\\zbcde{/;
            }
            $_=~s/\\zbcde{/\\abcde{/g;

            while (/\\abcdef{/) {
                &check_groups(6);
                $_=~s/\\abcdef{/\\zbcdef{/;
            }
            $_=~s/\\zbcdef{/\\abcdef{/g;

            while (/\\abcdefg{/) {
                &check_groups(7);
                $_=~s/\\abcdefg{/\\zbcdefg{/;
            }
            $_=~s/\\zbcdefg{/\\abcdefg{/g;

            while (/\\abcdefgh{/) {
                &check_groups(8);
                $_=~s/\\abcdefgh{/\\zbcdefgh{/;
            }
            $_=~s/\\zbcdefgh{/\\abcdefgh{/g;

            ##################################################
            # spreadsheet modification
            ##################################################
            # manage digits,numbers,strings
            if (/\\spshdigits{([0-9]+)}/) {
               $spreadsheet_digits=$1;
               print "   ### Spsh String: $spreadsheet_string\n";
               print "   ### Spsh Digits: $spreadsheet_digits\n";
            }
            if (/\\spshstring/) {
               $spreadsheet_string=1;
               print "   ### Spsh String: $spreadsheet_string\n";
               print "   ### Spsh Digits: $spreadsheet_digits\n";
            }
            if (/\\spshnostring/) {
               $spreadsheet_string=0;
               print "   ### Spsh String: $spreadsheet_string\n";
               print "   ### Spsh Digits: $spreadsheet_digits\n";
            }
            # single cell
            while (/\\spshcell{([0-9]+)}{([A-Z0-9]+)}/) {
                my $spreadsheet_table=$1;
                my $spreadsheet_cell=$2;

                my $cell_content = $spsh->[$spreadsheet_table]{$spreadsheet_cell};
                if (not defined $cell_content){
                    print "   spsh reference NOT LINKED: ",
                     "${spreadsheet_file}:${spreadsheet_table}:${spreadsheet_cell}\n";
                    $cell_content="\\textcolor{red}{${spreadsheet_table}".
			":${spreadsheet_cell}}";
                } else {
                    print "* spshcell reference found: ",
                     "${spreadsheet_file}:${spreadsheet_table}:${spreadsheet_cell}\n";
                }
                if ($file_info{'documentclass'}{'debug'}==1){
                    my $debug_content="\\textcolor{red}{$cell_content}".
                       "\\marginpar{\\textcolor{red}{${spreadsheet_table}:".
                       "${spreadsheet_cell}}}";
                    $_=~s/\\spshcell{([0-9]+)}{([A-Z0-9]+)}/$debug_content/;
                } else {
                    $cell_content=&modify_cell_content($cell_content);
                    $_=~s/\\spshcell{([0-9]+)}{([A-Z0-9]+)}/$cell_content/;
                }
            }

            # multiple cells
            while (/\\spshcells{([0-9]+)}{([A-Z])([0-9]+):([A-Z])([0-9]+)}/) {
                my $spreadsheet_table=$1;
                my $spreadsheet_start_cell_x=$2;
                my $spreadsheet_start_cell_y=$3;
                my $spreadsheet_end_cell_x=$4;
                my $spreadsheet_end_cell_y=$5;
                print "* spshcells reference found: ".$2.$3.":".$4.$5."\n";
                
                my @cell_list=();

                # horizontal or vertical ?
                my $horizontal=0;
                my $vertical=0;

                if ($spreadsheet_start_cell_y==$spreadsheet_end_cell_y){
                    # horizontal: numbers 1,2,3,4,5, ... ==
                    print "    Horizontal, Table $spreadsheet_table\n";
                    my $spreadsheet_y=$spreadsheet_start_cell_y;
                    print "      Start x:   $spreadsheet_start_cell_x \n";
                    print "      End x:     $spreadsheet_end_cell_x \n";
                    my @x_list=($spreadsheet_start_cell_x .. $spreadsheet_end_cell_x);
                    foreach my $item (@x_list){
                        my $cell=$item.$spreadsheet_y;
                        print "         -> $cell \n";
                        push @cell_list, $cell;
                    }
                } elsif ($spreadsheet_start_cell_x eq $spreadsheet_end_cell_x){
                    # vertical: letters A,B,C,D, ... equal (eq)
                    print "   Vertical, Table $spreadsheet_table\n";
                    my $spreadsheet_x=$spreadsheet_start_cell_x;
                    print "      Start y:   $spreadsheet_start_cell_y \n";
                    print "      End y:     $spreadsheet_end_cell_y \n";
                    my @y_list=($spreadsheet_start_cell_y .. $spreadsheet_end_cell_y);
                    foreach my $item (@y_list){
                        my $cell=$spreadsheet_x.$item;
                        print "         -> $cell \n";
                        push @cell_list, $cell;
                    }
                } else {
                    # neither horizontal, nor vertical
                    print "ERROR: Could not determine horizontal",
                          " or vertical speadsheet area\n";
                    exit;
                }


                my $replacement=$spsh_commands{$#cell_list+1};
                # save it for later use
                $file_info{'groups-real'}=$#cell_list+1;

                # I will create an \abcdefg...command
                # checking if groups match:
                &check_groups($#cell_list+1);

                my @cell_content_list=();
                my @cell_content_list_debug=();
                foreach my $cell (@cell_list){
                    my $cell_content = $spsh->[$spreadsheet_table]{$cell};
                    $cell_content=&modify_cell_content($cell_content);
                    push @cell_content_list, $cell_content;
                    push @cell_content_list_debug, 
                         "\\textcolor{red}{".$cell_content."}";
                }

                my $command_options="";
                if ($file_info{'documentclass'}{'debug'}==1){
                    # debug in red color
                    $command_options=join("}{", @cell_content_list_debug);
                } else {
                    $command_options=join("}{", @cell_content_list);
                }

                $replacement=$replacement.$command_options."}";
                $_=~s/\\spshcells{([0-9]+)}{([A-Z0-9]+):([A-Z0-9]+)}/$replacement/;
            }
            print TEXTEMP $_;
        }
        close(TEX);
    }
    if ( $i <= $file_info{'group-commands'} ){
         print TEXTEMP "\n\\newpage\n\n"; 
    }
}



print TEXTEMP '\end{document}';


# multiple groups
print "Decide what to compile on the following:\n";
print "  * Group Commands: $file_info{'group-selected'} \n";
print "  * Versions: $file_info{'group-commands'} \n";

if ( $file_info{'group-commands'}==0 or $file_info{'group-selected'} ne ""){
    print "Compiling this file\n";

    # compile the selected group, as requested
    &compile_tex($base_tmp);

    # PostScript Options
    my $file_to_view = &post_script_options($base_tmp);

    # start viewer   
    if ($noview==0){
        &viewer($file_to_view);
        #&viewer($base_tmp);
    }
    exit;
} elsif ( not $file_info{'group-commands'}==0 ){
    print "Creating files for all $file_info{'groups-real'} groups\n";

    my @psmerge_files=();
    for (my $i = 1; $i <= $file_info{'groups-real'}; $i++) {
        my $target_file=$base_tmp."-".$i.".tex";
        my $merge_file=$base_tmp."-".$i.".ps";
        my $option=$base_tmp."-".$i;

        print "   * Creating file $target_file and adding $group_commands{$i}\n";
        my $replace= " -e 's/^\\\\documentclass\[[a-z0-9,]*\]{teacher}/".
                     "\&\\n\\\\$group_commands{$i}/g'"; 
        my $command="cd $source_dir; sed $replace $tex_temp_file > $target_file";
        print "$command \n";
        system("$command");

        # editing group
        print "   * Compiling file $target_file with $group_commands{$i}\n";
        &compile_tex($option);

        push @psmerge_files, $merge_file;

    }

    # remove temporary file
    my $rm_command="cd $source_dir; rm $tex_temp_file";
    print "   * Removing temporary file $tex_temp_file\n";
    print "$rm_command \n";
    system($rm_command);

    my $psmerge_files=$#psmerge_files+1;
    print "Number of files to merge: $psmerge_files\n";

    if ($psmerge_files > 1){
        # merging files
        my $ps_merge_option=join(" ", @psmerge_files);
        my $filecount=1;

        print "modify $psmerge_files ps files so that they can be merged\n";
        foreach my $file (@psmerge_files){
            my $tmp_file="tmpfiledfrtghzuii".$filecount.".ps";
            system ("cd $source_dir; ps2ps $file  $tmp_file");
            system ("cd $source_dir; mv $tmp_file $file");
	    $filecount++;
        }

        print "Merging $psmerge_files files\n";
        my $all_groups_file=$base_tmp."-allgroups.ps";
        my $all_groups_file_viewer=$base_tmp."-allgroups";

        system ("cd $source_dir; psmerge -o$all_groups_file $ps_merge_option");

        # remove single group files
        foreach my $file (@psmerge_files){
            print "Removing $file\n";
            system ("cd $source_dir; rm $file");
        }

        # PostScript Options
        my $file_to_view = &post_script_options($all_groups_file_viewer);

        # start viewer with group 1   
        if ($noview==0){
            # view all groups file
            &viewer($file_to_view);
            #&viewer($all_groups_file_viewer);
        }
    } else {
        # PostScript Options
        my $one_group_file_viewer=$base_tmp."-1";
        my $file_to_view = &post_script_options($one_group_file_viewer);

        # nothing to merge
        if ($noview==0){
            &viewer($file_to_view);
        }
    }

    exit;

} else {
    print "ERROR: I do not know how to compile this file\n";
}






# Ende
print "##### jefflatex has compiled everything ---> done\n";





############################################################
# Subs
############################################################

sub anki_end_card {
    my ($note_end_count,$txt) = @_;
    print "   Card ${note_end_count}: detected %note-end\n";
    print ANKITMP "\\end{minipage}\\hspace{5mm}\n";
    print ANKITMP "\n";
    print ANKITMP "% Card ${note_end_count}: $_";
    print ANKITXT "[/latex];$txt";
}


sub print_anki_if_not_empty {
    my ($key,$value) = @_;
    if ($value ne ""){
        print ANKITMP ${key}.": ".$value."\n\n";
    }
}

sub print_anki_preamble {
    # now/fallback: use file in package
    # future: use python code in .anki ?????
    my $target_py_1=$home."/.anki/plugins/Configure\ latex.py";
    # Warn, when anki latex does not source problectix-makros
    my $string="\\input{/usr/share/problectix-anki/latex/preamble-input.tex}";
    my $command="grep $string \"$target_py_1\"";
    print "$command\n";
    my $result=system($command);
    print "$result\n";
    if ($result==0){
        # OK, looks good
        print "$string found\n";
        print "anki 1.2.x LaTeX Plugin configuration seems correct\n";
    } else {
        print "\nERROR in $target_py_1 :\n";
        print "$string is missing\n";
        print "anki 1.2 does not source problectix-anki preamble\n\n";
        #exit;
    }

    my $preamble="/usr/share/problectix-anki/latex/anki-preamble.tex";
    open(PREAMBLE, $preamble);
    while (<PREAMBLE>){
        print ANKITMP $_;
    }
    close(PREAMBLE);
}

sub print_anki_postamble {
    # now/fallback: use file in package
    # future: use python code in .anki ?????
    my $postamble="/usr/share/problectix-anki/latex/anki-postamble.tex";
    open(POSTAMBLE, $postamble);
    while (<POSTAMBLE>){
        print ANKITMP $_;
    }
    close(POSTAMBLE);
}

sub modify_cell_content {
    my ($old) = @_;
    print "Old content: $old\n";
    my $new=$old;
    # format numbers to requested digits
    if ($new=~m/^[0-9,.]+$/ and $spreadsheet_string==0){
        # thousend seperator -> small space
#        $new=~s/,/\\,/;
        $new=~s/,//;
        $new=sprintf("%.${spreadsheet_digits}f", $new);
        # dot -> comma
        $new=~s/\./,/;
    }
    # thousend seperator -> small space
#    $new=~s/,/\\,/;
    # dot -> comma
#    $new=~s/\./,/;
    #print "$old\n";
    print "New content: $new\n";
    return $new;
}



sub  check_options{
   my ($parse_ergebnis) = @_;
   if (not $parse_ergebnis==1){
      my @list = split(/\//,$0);
      my $scriptname = pop @list;
      print "\nSie haben bei der Eingabe der ",
            "Optionen einen Fehler begangen.\n"; 
      print "Siehe Fehlermeldung weiter oben. \n\n";
      print "... $scriptname beendet sich.\n\n";
      exit;
   } else {
         print "Alle Befehls-Optionen wurden erkannt.\n\n";
   }

}


sub check_file {
   open (TEXFILE, $tex_file);
   while (<TEXFILE>){
     # Leerzeichen ersetzen
     s/ //g;
     # check vorspann
     if (/^\%+.*alloptions=yes/){
        print "   ### alloptions found! \n";
        $file_info{'alloptions'}=1;
     } elsif (/\\spshfile{([A-Za-z0-9_.-]+)}/) {
        $spreadsheet_file=$1;
        $file_info{'spshfiles'}{$1}="yes";
        $file_info{'spreadsheet'}=1;
     } elsif (/^\\documentclass/) {
        # reguläre TEX-Datei
        print "   ### Type: Complete TEX-File\n";
        $file_info{'type'}="texfile";
        # kein Vorspann notwendig
        # analyze options
        if ( m/^\\documentclass\[([0-9A-Za-z,]+)\]/ ){
           my @options=split(/,/,$1);
           foreach my $option (@options){
	       print "   Option:  $option \n";
                  $file_info{'documentclass'}{'teacher'}=$option;
               if ($option eq "debug"){
		  print "   ### debug found! \n";
                  $file_info{'documentclass'}{'debug'}=1;
               } 
               if ($option eq "a5landscape"){
		  print "   ### a5landscape found! \n";
                  $file_info{'documentclass'}{'a5landscape'}="yes";
                  $a5_landscape=1;
               } 
               if ($option eq "a5landscaperepeat"){
		  print "   ### a5landscaperepeat found! \n";
                  $file_info{'documentclass'}{'a5landscaperepeat'}="yes";
                  $a5_landscape_repeat=1;
               } 
           }
        }
     } elsif ( /^\\order{([0-9]+)}/ ){
           $file_info{'order'}=$1;
     } elsif (/^%anki/ or /^%ankisimple/){
        # Anki Latex source file
        $file_info{'type'}="anki-latex-source";
     } elsif (/^\\begin{aufgabe}/){
        # Aufgabendatei gefunden
        # Vorspann ansetzen
        if (not exists $file_info{'documentclass'}){
           print "   ### Type: Aufgabendatei\n";
           $file_info{'type'}="problemfile";
        }
     } 

     if (/^%/){
         print "Comment: $_";
         next;
     }

     # are there \gruppea, \gruppeb, ... commands
     if (/\\gruppe([a-h])/) {
         $file_info{'group-selected'}=$1;
     }

     # ??????? this is done once again
     if ( /\\abcdefgh\{/ or /\\abcdefgh%/  ) {
        # 8 variations
        $file_info{'group-commands'}=8;
     } elsif ( /\\abcdefg\{/ or /\\abcdefg%/ ) {
        # 7 variations
        $file_info{'group-commands'}=7;
     } elsif ( /\\abcdef\{/ or /\\abcdef%/ ) {
        # 6 variations
        $file_info{'group-commands'}=6;
     } elsif ( /\\abcde\{/ or /\\abcde%/ ) {
        # 5 variations
        $file_info{'group-commands'}=5;
     } elsif ( /\\abcd\{/ or /\\abcd%/ ) {
        # 4 variations
        $file_info{'group-commands'}=4;
     } elsif ( /\\abc\{/ or /\\abc%/ ) {
        # 3 variations
        $file_info{'group-commands'}=3;
     } elsif ( /\\ab\{/ or /\\ab%/ ){
        # 2 variations
        $file_info{'group-commands'}=2;
     }
   }
   # exit if nothing usable (\documentclass, \begin{aufgabe}) found
   if ( not exists $file_info{'type'} ) {
        $file_info{'type'}="unknown";
        print "##### Type: Unknown, Please check your file.\n";
        exit;
    }
}


sub check_groups {
    my ($max_groups) = @_;
    print "Command $spsh_commands{$max_groups}} found  -> assuming $max_groups groups\n";
    if (not exists $file_info{'max_groups'}){
        $file_info{'max_groups'}=$max_groups;
    } else {
        if (not $max_groups==$file_info{'max_groups'}){
            print "Groups commands do not match:\n";
            print "   Groups: $file_info{'max_groups'} \n";
            print "   Groups: $max_groups \n";
            exit;
        }
    }
}


sub compile_tex {
   # Dateinamen
   my ($work_base_file) = @_;
   my $tex_temp_file="$base"."-temp.tex";
   my $tex_file = "$work_base_file".".tex";
   my $dvi_file = "$work_base_file".".dvi";
   my $ps_file  = "$work_base_file".".ps";
   my $png_file = "$work_base_file".".png";
   my $log_file = "$work_base_file".".log";
   my $aux_file = "$work_base_file".".aux";
   my $toc_file = "$work_base_file".".toc";
   my $exit_after_cleanup=0;
   # what to do
   if ( ($pdf==1 or 
         $png==1 or 
         $presentation==1) and 
           ( $a0_plus==1 or $a0==1 or $a1==1 or $a2==1 or $a3==1 or $a5==1 or 
             $pages ne "" or $target_file_opt ne "" or $target_dir_opt ne "") ){
       print "\nPostscript Options --a3, ... cannot be",
             " used with --pdf, --png and with --presentation\n\n";
       $exit_after_cleanup=1;
   } elsif ($pdf==1) {
       # pdflatexen
       print "##### jefflatex is starting pdflatex on:\n",
             "  $tex_file ($file_info{'max_groups'} Groups)\n...\n";
       system("cd $source_dir; pdflatex $tex_file && echo 'Done'");
       print "##### ending pdflatex ...\n";
   } elsif ($presentation==1) {
       # latexen
       print "##### jefflatex is starting latex on:\n",
             "  $tex_file ($file_info{'max_groups'} Groups)\n...\n";
       system("cd $source_dir; latex $tex_file");
       system("cd $source_dir; latex $tex_file");
       print "##### ending latex ...\n";
       # pdf erzeugen
       print "##### jefflatex is  starting dvipdf on:\n",
             "  $dvi_file \n...\n";
       system("cd $source_dir; dvipdf $dvi_file");
       system("cd $source_dir; dvipdf $dvi_file");
       print "##### ending dvipdf ...\n";
   } elsif ($png==1) {
       # latexen
       print "##### jefflatex is starting latex on:\n",
             "  $tex_file ($file_info{'max_groups'} Groups)\n...\n";
       system("cd $source_dir; latex $tex_file");
#       system("cd $source_dir; latex $tex_file");
       print "##### ending latex ...\n";
       # Postscript erzeugen
       print "##### jefflatex is starting dvips on:\n",
             "  $dvi_file \n...\n";
       print "$dvi_file in $source_dir\n";
#       system("cd $source_dir; dvips -x2074 -y2074 -T 50cm,120cm $dvi_file");
       system("cd $source_dir; dvips -x$width -y$width -T 50cm,120cm -E $dvi_file $dvips_string");
       print "##### ending dvips ...\n";
       # png erzeugen
       print "##### jefflatex is converting: \n  $ps_file\n to:\n  $png_file\n \n...\n";
       system("cd $source_dir; convert -crop 0x0   $ps_file png:$png_file");
       print "##### ending convert ...\n";

   } else {
       #latexen und dvips
       print "##### jefflatex is starting Latex on:\n  $tex_file \n...\n";
       system("cd $source_dir; latex $tex_file");
       system("cd $source_dir; latex $tex_file");
       print "##### ending Latex ...\n";
       # Postscript erzeugen
       print "##### jefflatex is starting dvips on:\n  $dvi_file \n...\n";
       system("cd $source_dir; dvips $dvi_file $dvips_string");
       print "##### ending dvips ...\n";
      
      if ($a5_landscape==1){   
         my $command="cd $source_dir; ".
                     "a5-landscape-on-a4 $ps_file ${ps_file}-temp empty; ".
                     "mv ${ps_file}-temp $ps_file";
         print "Modifying result with $command ...\n";
         system($command);
      }
      if ($a5_landscape_repeat==1){
	  my $command="cd $source_dir; ".
                      "a5-landscape-on-a4 $ps_file ${ps_file}-temp repeat; ".
                      "mv ${ps_file}-temp $ps_file";
         print "Modifying result ...\n";
         system($command);
      }
   }

   # Aufräumen
   #&clean($tex_file);
   &clean($dvi_file);
   &clean($log_file);
   &clean($aux_file);
   &clean($toc_file);
   if ($png==1){
       &clean($ps_file);
   }
   if ($exit_after_cleanup==1){
       # clean up the -temp.tex
       &clean($tex_temp_file);
       exit;
   }
}



sub post_script_options {
    # filename comes without extension
    my ($file_to_modify_ps)=@_;
    
    # the temporary file
    my $ps_tmp = "$file_to_modify_ps".".tmp.ps";
    # the file we are working on
    $file_to_modify_ps = $file_to_modify_ps.".ps";

    my $file_to_view_ps = $file_to_modify_ps;
    ########################################
    # post texing options
    ##########
    # page selection
    if ($pages ne ""){
        print "Selecting only the pages $pages\n";
        my $command="cd $source_dir;".
                    " psselect -p$pages $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    ##########
    # scaling
    # pstops -d1 ... to show frame
    # w and h are in points: 1pt = 0,353 mm

    if ($a0_plus==1){
        print "Scaling up to A0+ ... 906 x 1266 mm\n";
        my $command="cd $source_dir;".
                    " pstops -w2569  -h3590 \"\@4.26\" $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    if ($a0==1){
        print "Scaling up to A0 ... 841 x 1189 mm\n";
        my $command="cd $source_dir;".
                    " pstops -w2384  -h3370 \"\@4.0\" $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    if ($a1==1){
        print "Scaling up to A1 ... 594 x 841 mm\n";
        my $command="cd $source_dir;".
                    " pstops -w1684  -h2384 \"\@2.8284\" $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    if ($a2==1){
        print "Scaling up to A2 ... 420 x 594 mm\n";
        my $command="cd $source_dir;".
                    " pstops -w1190  -h1684 \"\@2.0\" $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    if ($a3==1){
        print "Scaling up to A3 ... 297 x 420 mm\n";
        my $command="cd $source_dir;".
                    " pstops -w841  -h1190 \"\@1.4142\" $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    if ($a5==1){
        print "Scaling down to A5 ...\n";
        my $command="cd $source_dir;".
                    " pstops \"2:0L\@.7(20.9cm,0.1cm)+1L\@.7(20.9cm,14.85cm)\" $file_to_modify_ps $ps_tmp;".
                    " mv $ps_tmp $file_to_modify_ps";
        print "$command\n";
        system($command);
    }
    ##########
    if ($target_file_opt ne ""){
        # renaming
        my $command="cd $source_dir;".
                    " mv $file_to_modify_ps $target_file_opt;";
        print "$command\n";
        system($command);
    }
    if ($target_dir_opt ne ""){
        # moving 
        my $move="";
        if ($target_file_opt ne ""){
            $move="cd $source_dir;".
                  " mv $target_file_opt $target_dir_opt;";
        } else {
            $move="cd $source_dir;".
                  " mv $file_to_modify_ps $target_dir_opt;";
        }    
        print "$move\n";
        system($move);
    }
    ##########
    # moving
    print "\n";
    print "File to modify:  $file_to_modify_ps\n";
    print "File to view:    $file_to_view_ps\n\n";

    return $file_to_view_ps;
}


sub modify_ps_old {
  my $ps_file = "$base".".ps";
  if ($a5_landscape==1){   
      my $command="a5-landscape-on-a4 $ps_file $ps_file empty";
      print "Modifying result with $command ...\n";
      #system($command);
  }
  if ($a5_landscape_repeat==1){
      my $command="a5-landscape-on-a4 $ps_file $ps_file repeat";
      print "Modifying result ...\n";
      #system($command);
  }
}


sub viewer {
   my $found=0;
   # Dateinamen
   my ($work_base_file) = @_;
#   my $work_base_file="$base"."-temp";
#   my $ps_file  = "$work_base_file".".ps";
   my $ps_file  = $work_base_file; # postscript modificator return filename with .ps added
   my $pdf_file = "$work_base_file".".pdf";
   my $png_file = "$work_base_file".".png";

   if ($pdf==1 or $presentation==1) {
       # pdf-viewer
       print "##### jefflatex is starting a PDF-viewer on $pdf_file ...\n";
       foreach my $viewer (@pdf_viewer) {
	  if ($found==1){next;};
          if (-e "$viewer") {
              if ($viewer=~/\/xpdf/ and $presentation==1){
                 system("$viewer -fullscreen $pdf_file");
              } else {
                 system("$viewer $pdf_file && echo 'Viewer terminated'");
	      }
              $found=1;
          }
       }
       print "##### ending PDF-viewer ...\n";
   } elsif ($png==1) {
       # png-viewer
       if (-e $png_file){
          &png_viewer($png_file);
      } else {
          # Hide misleading error: viewer not found   
          $found=1;
          print "$png_file does not exist! \n";
          for (my $i = 0; $i <= 9; $i++) {  # count from 0 to 5
              my $file_base = basename($png_file,".png");
              my $dir_base = dirname($png_file);
              my $file= $dir_base."/".$file_base."-".$i.".png";
              print "   Looking for $file \n";       
              if (-e $file){
                 &png_viewer($file);
	      }
          }
      }
   } else {
       #ps-viewer
       if ($target_dir_opt ne "" or $target_file_opt ne ""){
           print "##### jefflatex does not start viewer when target file is somewhere else ...\n";
           $found=1;
       } else {
           print "##### jefflatex is starting a PS-viewer on $ps_file ...\n";
           foreach my $viewer (@ps_viewer) {
	       if ($found==1){next;};
               if (-e "$viewer") {
                   system("$viewer $ps_file && echo 'Viewer terminated'");
                   $found=1;
               }
           }
           print "##### ending PS-viewer ...\n";
       }
   }

   # Fehler, wenn kein Viewer gefunden wurde
   if ($found==0){
       print "Konnte keinen Viewer finden!\n";
       print "Bitte prüfen Sie:\n";
       print "   $sys_config  \n";
       print "   $user_config  \n";
   }

   # Temporäre Dateien löschen
   #sleep 8; # wait for viewer to display pdf
   &clean($ps_file);
   &clean($pdf_file);
   &clean($png_file);
}



sub png_viewer{
    my ($file) = @_;
    print "##### jefflatex is starting a PNG-viewer on $file ...\n";
    foreach my $viewer (@png_viewer) {
      if ($found==1){next;};
        if (-e "$viewer") {
	  print "Viewer= $viewer\n";
            system("$viewer $file");
            $found=1;
        }
      }
    $found=0;
    print "##### ending PNG-viewer on $file ...\n";
}



sub clean {
    my ($delete_file) = @_;
    if (-e $delete_file) {
        print "##### cleaning up $delete_file \n";
	system("rm $delete_file");
    }
}



