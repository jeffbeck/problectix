#!/usr/bin/perl -w
# Dieses Script (problectix-collection) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de

# Bibliotheken
use strict;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use File::Find;
use File::Path; # rmtree, ...
use File::Basename;
#use Time::Local;
use Time::localtime;
#use Schedule::at;
#use Term::ANSIColor qw(:constants); # farbiger Text RED, BLUE, ...

use problectix;

# Einlesen der Konfigurationsdatei für Entwickler
#{ package DevelConf ; do "/etc/sophomorix/devel/user/sophomorix-devel.conf"}

# jeffbecks Bibliothek und
# Einlesen der Konfigurationsdatei
#require "${DevelConf::library_pfad}/sophomorix-lib";

# in allen Pfad-ausgaben soll /home/bz fehlen


# www: 
# in usermin: cgi-script, dass source-code sucht. wird mit dem aufgerufen
# oder abs-pfad mitspeichern und link anlegen: file:///
# evtl. letzte Möglichkeit: beim erstellen der aufgaben(.tex->png) abspeichern



# überlegen: option www nimmt immer alle Aufgaben 
# (in --schueler, --lehrer, und --loesungs-Version)
# --lehrer: links auf src
# --schueler: keine links auf source
#             beliebiger zielpfad angebbar (z.B. Public_html)
# --loesung
# bel. Zielpfad

# in *.conf eine LISTE mit Aufgabentrees, sie machen die Gesamtmenge 
# der Aufgaben aus
# Aus dieser Gesamtmenge können Projekte zusammengefasst werden
# diese Pfade müssen in $TEXINPUTS enthalten sein
# am besten diese Variable auswerten, sonst muss man alles doppelt machen
# usermin: wenn $texinputs lerr, dann entspr. Meldung was durchsuchen

# Check-Script, das auf solche Fehler hin prüft und tipps gibt
# Error erzeugen, wenn derselbe Dateinamen doppelt vorkommt


# Beim Erstellen von png's sollen nur die veränderten *.tex-dateien neu compiliert
# werden 



#USERMIN

# Main Pages
#  - Projects
#        - aktives Projekt
#           <ps loesung erzeugen>
#           <ps lehrer>
#           <ps schueler>
#           <html> ...
#        - andere Projekte auflisten
#           <aktivieren> <bearbeiten>


#  - Konfiguration
#       - texinputs konfigurieren
#       - ...

# - Aufgabe erstellen
#   (Datei Temporär in extraverzeichnis halten,
#    dort editieren, kompilieren, prüfen.
#    wenn erfolgreich abgeschlossen, dann in ein Verzeichnis einordnen)
#       - Vorlage auswählen(png-preview) 
#       - Editorfenster (html)
#       
# - CVS-Server-Modul
#       -einchecken/auschecken
#       -konfigurieren

# Hash mit Verzeichnissen, in denen nicht mehr weitergesucht werden soll
my %exclude_dirs = qw(ARB ignore
                      INFO ignore
                      WORK ignore
                      FOL ignore
                      LAB ignore
                      FOIL ignore
                      BB ignore
                      TEST ignore
                      EXAM ignore
                      exam ignore
                      sonstiges ignore
                     );

my %add_zero = qw( 0 00
                   1 01
                   2 02
                   3 03
                   4 04
                   5 05
                   6 06
                   7 07
                   8 08
                   9 09
		  );

my @projects=();
# Datenbank für alle erzeugten png's
my %png_db=();
my $key;
my $value;
# ==========================================================================
# Variablen für Optionen
# ==========================================================================
my $help=0;
my $info=0;
my $verbose=0;
my $set="";
my $start_path="";
my $command_line_path="";
my $abs_command_line_path="";
my $www=0;
my $ps=0;
my $renew=0;
my $schueler=0;
my $exam=0;
my $kamulti=0;
my $loesung=0;
my $lehrer=0;
my $type_name="";
my $practice=2;
my $all=0;
my $ignored_dirs=0;
my $count_prob=0;
my $counter_problems=0;
my $browsetree=0;
my $create="";
my $remove="";
my $search="";
my $match_practice="";
my $string_printout="";
my $layout="";


my $order_number="777";

my $out_path="";
my $out_ps="";
my $out_ps_browsetree="";
my $out_html="";
my $out_html_browsetree="";



my $project_number=0;
my $active;

my @dir_list=();

# $HOME ermitteln
my $home="$ENV{'HOME'}";
# print "Homeverzeichnis ist:     \n  $home \n\n";   

### KONFIGURATION

# systemweite Konfiguration
my $sys_config = "/etc/problectix/problectix.conf";
# userabhaengige Konfiguration
my $config_dir="$ENV{'HOME'}/.problectix";
my $user_config="$config_dir"."/.problectix";
# projekte eines users
my $project_dir="$config_dir/projects";
# aktives projekt eines users
my $active_project="$project_dir"."/.project";



# ===========================================================================
# Konfigurations-Dateien sourcen
# ==========================================================================

# Abbruch, falls sysweite config fehlt
if (not -e $sys_config) {
    print "$sys_config does not exist. exiting ...\n\n";
    exit;
} else {
   # werte der sysconfig einlesen
   { package SysConf ; do "$sys_config"}
    $out_path="$SysConf::output_path";
    $start_path="$SysConf::start_path";
}



# userweit, falls existent
if (-e "$user_config") {
   { package UserConf ; do "$user_config"}
   $out_path="$UserConf::output_path";
   $start_path="$UserConf::start_path";
}



# dummy
if($SysConf::output_path){};
if($SysConf::start_path){};
if($UserConf::output_path){};
if($UserConf::start_path){};



# ===========================================================================
# Optionen verarbeiten
# ==========================================================================
# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$verbose,
           "info|i" => \$info,           
           "set=s" => \$set,           
           "help|h" => \$help,
           "www" => \$www,
           "ps" => \$ps,
           "student" => \$schueler,
           "exam" => \$exam,
           "kamulti" => \$kamulti,
           "teacher" => \$lehrer,
           "solution|lsg" => \$loesung,
           "renew" => \$renew,
           "browsetree|tree" => \$browsetree,
           "create=s" => \$create,
           "remove=s" => \$remove,
           "practice" => \$practice,
           "all" => \$all,
           "ignored-dirs" => \$ignored_dirs,
           "count" => \$count_prob,
           "layout=s" => \$layout,
           "search=s" => \$search,
           "path=s" => \$command_line_path,
          );



# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&problectix::check_options($testopt);

if ($ps==1 and $www==1) {
    print "You cannot say --www AND --ps\n\n";
    exit;
}

# --ignored-dirs
if ($ignored_dirs==1){
    my @ignored=();
    print "\nIgnored directories in $start_path\n";
    while (($key,$value) = each %exclude_dirs){
        push @ignored, $key;
    }

    @ignored = sort @ignored;
 
    foreach my $dir (@ignored){
	print "   $dir \n";
    }
    exit;
}

# --schueler, --lehrer, --loesung
if ($schueler==1){
    $type_name="student";
} elsif ($exam==1){
    $type_name="exam";
} elsif ($kamulti==1){
    $type_name="kamulti";
} elsif ($lehrer==1){
    $type_name="teacher";
} elsif ($loesung==1){
    $type_name="solution";
} elsif ($browsetree==1){
    # option browsetree
    # wenn nichts anderes angegeben, dann lehrer(Aufgabe und Lösung)
    $type_name="lehrer";
    $lehrer=1;
} elsif ($count_prob==1){
    $type_name="count";
} else {
    $type_name="(schueler/lehrer/loesung)";
    if ($info==0 and $set eq ""){
       $help=1;
    }
}


# --path
if ($command_line_path ne "") {
    # pfad muss absolut angegeben werden
    # ????? relativer Pfad umbiegen
    $start_path = $command_line_path;
}


# --search
if ($search ne ""){
    print "* Searching for ${search} in $start_path ... \n";
    my $command="grep \"$search\" -r -i -n $start_path";
    print "* Using: $command\n";
    my $result=`$command`;
    my @lines = split(/\n/,$result);

    @lines = sort @lines;
    my $count=0;

    foreach my $res (@lines){
        my ($path,$line_number) = split(/:/,$res);
        if (not $path=~/\.tex$/){
            next;
        }
        $count++;
        print "$count) $path (Line $line_number):\n";
        my ($pre,$string) = split( /:${line_number}:/ ,$res);

        if ($verbose==0){
            print "   $string \n";
        } else {
            &print_lines($path,$line_number);
        }
    }
    exit;
}


# --count
if ($count_prob==1){
    $browsetree=1;
}



# --create
if ($create ne "") {
    if ($command_line_path eq "") {
	print "Um ein Projekt zu erstellen muss",
              " --path pfadname angegeben werden.\n";
        exit;
    }
    # / am ende anfügen (Verzeichnis)
    if (not $command_line_path=~/\/$/){
        $command_line_path="$command_line_path"."/";
    }
    # Absoluten Pfad ermitteln
    if ($command_line_path=~/^$home/){
        $abs_command_line_path=$command_line_path;
    } else {
        $abs_command_line_path=$home."/"."$command_line_path";
    }
    # erstellen, falls existent
    if (-e "$abs_command_line_path"){
        # make dir relative
        $command_line_path=$abs_command_line_path;
        $command_line_path=~s/^$home\///;  
        # creating the project
        print "Erstelle Projekt $create ...\n";
        open(NEWPRO, ">$project_dir/$create") || 
            die "Cannot create $project_dir/$create\n";
        print NEWPRO "$command_line_path\n";
        close(NEWPRO);
        # making the project active, when no project is active
        $active=&problectix::get_active_project();
        if (not defined $active) {
            print "Projekt $create wird aktiviert.\n";
            # neues Link anlegen
            system("cd $project_dir; ln -s $create .project");
        }
    } else {
	print "ERROR: Konnte Projekt nicht erstellen:\n";
	print "  $abs_command_line_path existiert nicht!\n";
        exit;
    }
}


# Handling the active project
$active=&problectix::get_active_project();
# Determining the browsetree-dirs
$out_html_browsetree="$SysConf::browsetree_path/html-$type_name";
$out_ps_browsetree="$SysConf::browsetree_path/ps-$type_name";


# --browsetree
if ($browsetree==0) {
    if (defined $active){
       print "\nDas aktive Projekt ist:  \n",
             "  $active \n";   
       $out_ps="$out_path"."/$active";
       $out_html="$out_path"."/html/$active";
       # sicherstellen, dass Output_dir existiert
   } else {
       print "\nKein aktives Projekt vorhanden!\n";
   }
    if (not -e $out_path){
        print "Creating $out_path ...\n";
        system("mkdir $out_path");
    }
} else {
    # option browsetree
    # make sure to compile all problems 
    $all=1;
    #print "Option browsetree angegeben.\n";
    $out_html="$out_html_browsetree";
    $out_ps="$out_ps_browsetree";
    $active="Aufgabensammlung";
    print "\nDer html-browsetree wird erstellt in: \n",
          "   $out_html \n";
    # Bei renew den ganzen bisherigen tree löschen
    if (not -e $SysConf::browsetree_path) {
        # Anlegen
        print "Creating $SysConf::browsetree_path ...\n";
        system("mkdir $SysConf::browsetree_path");
    } elsif ($renew==1) {
         # Löschen und neu anlegen
         rmtree("$SysConf::browsetree_path"); 
         system ("mkdir $SysConf::browsetree_path");
    }
    &read_png_db();
}



# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print "$scriptname erzeugt eine Aufgabensammlung aus einem \n";
   print "Verzeichnis von Aufgaben im *.tex-Format.\n";

   # optionen
   print('
Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose

Manage projects:
  -i / --info
  --set n
  --create project
  --path path_to_project_dir
  --remove project

Create project of ALL problems
  --browsetree, --tree (creates PostScript)

  Optional Parameters:
     --www (create html instead of PostScript)
     --renew (recreate all problems)

Choose formatting:
  --student
  --teacher
  --solution
  --kamulti
  --layout option

Count problems only:
  --count

What kind of problems to use:

   Use all problems:
      --all

   Use only problems marked with the \'-U\' tag:
      --practice (default)

Please see the problectix(1) man page for full documentation
');
   print "\n";

   exit;
}




# --practice/--all
if ($all==1 and $practice==1){
    print "\n You have to choose either --practice OR --all\n\n";
    exit;
} elsif ($all==1){
    $practice=0;
}

if ( ($practice==1 or $practice==2) and $all==0) {
   # default
   $match_practice="-U";
   $string_printout="practice";
} elsif ($practice==0 and $all==1) {
   # show all
    $string_printout="all";
}

# Ausgabe der gueltigen Werte
print "\nNach Aufgaben wird gesucht in:\n",
      "   $start_path\n";
print "\nDie Projekt-Aufgabensammlungen werden erstellt in:\n",
      "   $out_path\n";
print "\nDie Gesamt-Aufgabensammlungen werden erstellt in:\n",
      "   $SysConf::browsetree_path\n";
print "\nDie Projekte sind definiert in:  \n",
      "   $project_dir \n";   

# sicherstellen, dass Projektverzeichnis existiert
if (not -e $config_dir){
    print "Creating $config_dir ...\n";
    system("mkdir $config_dir");
}
if (not -e $project_dir){
    print "Creating $project_dir ...\n";
    system("mkdir $project_dir");
}



# --remove
if ($remove ne "") {
    if (-e "$project_dir/$remove") {
      # removing the project
      print "Entferne Projekt $remove ...\n";
      system("rm $project_dir/$remove");
      print "Done.\n";
      print "Daten in $out_path/$remove habe ich nicht gelöscht.\n";
  } else {
      print "\nFEHLER::Konnte die zum löschenden Projekt gehörende Datei\n";
      print "   $project_dir/$remove \n";
      print "nicht finden.\n\n";
  }
  exit;
}



# Abbruch, falls kein aktives Projekt existiert
if (not defined $active){
    print "\nEs gibt kein aktives Projekt\n";
    print "Legen sie ein Projekt an mit der option --create\n";
    print "Siehe auch in der Hilfe ( --help)\n\n";
    exit;
}



# Start-verzeichnis-name ermitteln
# start-path = absolut
#start-dir   = Verzeichnis-Name
my @list = split(/\//,$start_path);
my $start_dir = pop @list;

# Welche Verzeichnisse durchsucht werden müssen
# Am Beginn nur das Startverzeichnis
my @verzeichnisliste=($start_dir);




# --info
if ($info==1 or $set ne "") {
    #print "\n\nGefundene *.tex-Dateien:\n";
    #foreach my $datei (@tex_dateien) {
	#print "$datei\n";
    #}
    #exit;
  
    # Projekt-Liste zum setzen erstellen
    @projects=&problectix::get_project_list();

    print "\nProjekte:\n";

    if ($set ne "") {
        # anderes projekt aktivieren
        if (defined $projects[$set]){
           # sinnvoller wert übergeben 
           print "setze aktives Projekt auf $set\n";
           # altes Link entfernen
           print "$active_project\n";
           unlink $active_project;
           # neues Link anlegen
           system("cd $project_dir; ln -s $projects[$set] .project");
           # Projekt-Liste aktualisieren zum Anzeigen
           @projects=&problectix::get_project_list();
        } else {
           # sinnloser Wert uebergeben
	   print "\nAbbruch:\n";
           print "Es gibt kein Projekt mit dem Index $set\n";
           exit;
        }
    } else {
        # nichts tun
        #print "setze nicht\n";
    }

    # Liste aller Projekte ausgeben
    foreach my $project (@projects){        
        my @dir_listing=&problectix::get_dirlist_of_project($project);
        # Nummer des Projects ausgeben
        if ($project_number==0){
           # current project
           print "   (*)";
        } else {
	   print ("   ($project_number)");
        }

        my ($latex_name)=&problectix::get_info_of_project($project);
        # Name des Projekts ausgeben
        print "$project ($latex_name)\n";

        # Liste der Verzeichnisse ausgeben
        foreach my $dir (@dir_listing) {
	    if (-e $dir){
                # dir exists
                print "    -- $dir\n";
            } else {
                if ($dir=~/^LATEXNAME=/){
	           next;
                } else {
                   # dir points to nowhere
                   print "       NONEXISTING: $dir\n";
                }
            }
        }
        $project_number++;
    }
    # beenden der --info-Option
    exit;
}









# ===========================================================================
# Aufgabensammlung erzeugen
# ==========================================================================

my @project_list=();
my $curr_project="";
# Projekt oder Alle Aufgaben?
if  ($browsetree==0) {
   # Projektliste erstellen, in erstem Element ist das Standardprojekt
   @project_list=&problectix::get_project_list();
   $curr_project=$project_list[0];
   @dir_list=&problectix::get_dirlist_of_project($curr_project);
} else {
   # Alle Aufgaben
   @dir_list=($start_path);   
}


foreach my $line (@dir_list){
    print "+  $line \n";
}

&aufgabensammlung(@dir_list);

# end of programm is in function 'last_exit'






# ===========================================================================
# Subroutinen
# ==========================================================================

sub get_order_number{
    # opens a file and reads an order=number entry
    my ($aufgabe) = @_;
    # Standardwert
    my $order="9999";
    my $a;
    #print "Aufgabe: $aufgabe\n";
    open (AUORDER, "<$aufgabe") || die "$aufgabe: $!";
    while (<AUORDER>){
        chomp();   
        s/\s//g;
        if ( /^\\order{([0-9]+)}/ ){
           $order=$1;
        }
        next;
# looks for  % order=123
#        chomp();   
#        s/\s//g;
#        s/%//g;
#        if (/order=/) {
#	  ($a, $order)=split(/=/);
#        next;
#        }
    }
    close(AUORDER);
    return "$order";
}


sub png_von_aufgabe{
    # Parameter ist der absolute Dateipfad
    # der *.tex-Datei mit der Aufgabe
    my ($datei_pfad) = @_;
    my @list = split(/\//,$datei_pfad);
    my $datei = pop @list;
    my $datei_ohne_tex = $datei;
    my $gen_png="$out_html"."/"."$datei"."-gen.png";
    my $order_number=&get_order_number($datei_pfad);
    # decide if a new png is needed
    my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev,
    $size, $atime, $mtime, $ctime, $blksize, $blocks)
    = stat($datei_pfad);
    if ($verbose>0){
        print " Checking if I should create  $gen_png\n\n";
    }
    if (not exists $png_db{$datei} or 
       (not -e $gen_png) or
       (exists $png_db{$datei} and $png_db{$datei} ne $mtime)){
       # create a png
       my $png_to_mv=$datei_pfad;
       $png_to_mv=~s/.tex$/-temp.png/g;
       print "+ $datei: Creating $gen_png\n";       
       print "    compiling $datei ...\n";       
       system("jefflatex --file $datei_pfad --png --noview --silent-dvips > /dev/null");

       if (-e $png_to_mv){
           if ($verbose>0){
               print "\n mv $png_to_mv $gen_png \n\n";
           }
           system("mv $png_to_mv $gen_png");
       } else {
           # multipages png
	   # move the main file
           my $file_base = basename($png_to_mv,".png");
           my $dir_base = dirname($png_to_mv);
           my $png= $dir_base."/".$file_base."-0.png";
           my $app="";
           print "   Looking for file     $png \n";       
           if (-e $png){
              system("mv $png $gen_png");
	   }
           # move the appendixes
           for (my $i = 1; $i <= 9; $i++) {  # count from 1 to 5
              my $file_base = basename($png_to_mv,".png");
              my $dir_base = dirname($png_to_mv);
              my $png= $dir_base."/".$file_base."-".$i.".png";
              $app=$gen_png."-app".$i;
              print "   Looking for appendix $png \n";       
              if (-e $png){
                  system("mv $png $app");
	      }
          }
       }
       # neuer Datenbankeintrag machen
       $png_db{$datei}=$mtime;
   } else {
       print "- $datei\n";
   }
}


sub aufgabensammlung {
    # Übergeben wurde der Start-Pfad
    # Dieser ist nun als einziges in der Verzeichnisliste
    my @verzeichnisliste = @_;
    my @tex_list = ();
    my $work_dir;

    &verzeichnis_vorbereiten();
    &index_datei_beginnen();

   # Beginn der while-Schleife, solange es Verzeichnisse gibt
   while (1==1) {
      # Erstes Element aus der Verzeichnisliste holen 
      # (Element wird aus array entfernt)
      # $work_dir ist enthält absoluten Pfad
      $work_dir = shift(@verzeichnisliste);
 
      # Ausstieg, wenn @verzeichnisliste leer ist
      if (not defined $work_dir) {
          # Programmende
          &last_exit();
      }

      # $dir   : Verzeichnisname (ohne Pfad) 
      my @pathlist = split(/\//,$work_dir);
      my $dir = pop @pathlist;
      # Pfadliste leeren
      @pathlist = ();

      # Gibt es *.tex-Dateien
      @tex_list=&list_tex_dateien($work_dir);
   

      foreach my $line (@tex_list){
	  print " - $line \n";
      }

      # Gibt es Verzeichnisse
      my @dir_list=&list_dirs($work_dir);
  
      # do something with the value
      if (defined $tex_list[0]) {
          # Tex-Dateien bearbeiten, falls Liste nicht leer
          if ($count_prob==1){
              # count only
              foreach my $file (@tex_list){
                  $counter_problems++;
              }
          } elsif ($www==0) {
	      &tex_eintraege($dir,@tex_list);
          } elsif ($www==1) {
             #print "\n\nDIR: $dir\n\n";
             #print "Liste:  @tex_list\n\n";
             &html_seite_erstellen($dir,@tex_list);
          }
          # Link auf diese Datei Erstellen in index.html
          if ($www==0) {
          # nichts tun
          } elsif ($www==1) {
            print INDEX "<h3><A HREF=\"",
                        "$dir.html",
                        "\">",
                        "$dir",
                        "</A></h3>",
                        "\n";
          }
      } elsif (not defined $dir_list[0]) {
          # mini-Überschrift erstellen (Verzeichnis ist leer)
          if ($count_prob==1){
              # do nothing
          } elsif ($www==0) {
             print PROBLECTIX "\n","\\section{",
                              "$dir (noch keine Aufgaben)}\n";
          } elsif ($www==1) {
             print INDEX '<h4>',"$dir"," &nbsp; (noch keine Aufgaben)",
                         '</h4>',"\n";
          }      
      } else {
          # Große Überschrift (übergeordnetes Verzeichnis)
          if ($www==0) {
   
          } elsif ($www==1) {
             print INDEX '<h1>',"$dir",'</h1>',"\n";
	  }
      }

      # Verzeichnisse in Verzeichnisliste laden
      unshift @verzeichnisliste, @dir_list;
 
      # png-datenbank schreiben, als backup
      if ($browsetree==1) {
         &write_png_db;
      }
   }# Ende der While-Schleife

}






sub lastname_von_abs_pfad {
    # Parameter: absoluter Pfad
    # sub gibt letzter Name (Verzeichnis oder Datei) zurück
    my ($abs_pfad) = @_;
    my @pathlist = split(/\//,$abs_pfad);
    my $lastname = pop @pathlist;
    return $lastname;
}



sub list_tex_dateien {
   # Gibt alle *.tex-Dateien des übergebenen Verzeichnisses zurück
    my ($verzeichnis) = @_ ;
    my @tex_dateiliste = ();
    if ($verbose>0){
        print "\nSuche *.tex-Dateien im Verzeichnis $verzeichnis ...\n";
    }
    if ($verzeichnis=~/^LATEXNAME=/){
        push (@tex_dateiliste, $verzeichnis);
    } else {
       opendir(DIR, $verzeichnis) || die "Kannx $verzeichnis nicht öffnen: $!";
       while (defined (my $file = readdir(DIR))) {
          # Eintrag verarbeiten
          if ($verbose>0){
              print "Gefunden: $file     ---";
          }
          if ($file=~/${match_practice}.tex$/
              ) {
              if ($verbose>0){
                  print "ist eine *.tex-Datei\n";
              }
              $file="$verzeichnis"."/"."$file";
              push (@tex_dateiliste, $file);
          } else {
              if ($verbose>0){
	         print " ist keine *.tex-Datei\n";
              }
          }
      }
    }
    closedir(DIR);
    return @tex_dateiliste;
}



sub list_dirs {
   # Gibt alle Verzeichnisse des übergebenen Verzeichnisses zurück
   # ohne die in der exclude-liste enthaltenen
    my ($verzeichnis) = @_ ;
    my @dirs = ();
    if ($verbose>0){
        print "\nSuche Verzeichnisse im Verzeichnis $verzeichnis ...\n";
    }

    if ($verzeichnis=~/^LATEXNAME/){
    } else {    
      opendir(DIR, $verzeichnis) || die "Kann $verzeichnis nicht öffnen: $!";
      while (defined (my $eintrag = readdir(DIR))) {
          my $abs_eintrag="$verzeichnis"."/"."$eintrag";
          # Eintrag verarbeiten
          if ($verbose>0){
              print "Gefunden. $eintrag --- ";
          }
          if (-d $abs_eintrag &&  # verbessern ?????????????????
                 $eintrag ne "auto" && 
                 $eintrag ne ".xvpics" && 
                 $eintrag ne "." &&
                 $eintrag ne "CVS" &&
                 $eintrag ne "..") {
              if ($verbose>0){
   	          print " ist Verzeichnis\n";
              }
              if (exists $exclude_dirs{$eintrag}){
                  print "   ... Verzeichnis $eintrag wird ignoriert!\n";
              } else {
                  push (@dirs, $abs_eintrag);
	      }
          } else {
              if ($verbose>0){
                  print " KEIN Verzeichnis\n";
              }  
	  }
        
      }
      closedir(DIR);
    }
    @dirs = sort @dirs;
    return @dirs;
}



sub tex_eintraege {
   my ($name, @dateien) = @_;
    print "\n\n HERE @dateien \n\n";
   my @dateien_order=(); 
   my $aufgabe="";
   my $order_number="99999";
   foreach $aufgabe (@dateien) {
       if ($aufgabe=~/^LATEXNAME/){
           my ($key,$latex_name)=split(/=/,$aufgabe);
           print PROBLECTIX "\n","\\section{$latex_name}\n";
	   next;
       }
       $order_number=&get_order_number($aufgabe);
       push (@dateien_order, "$order_number"."___"."$aufgabe");
   }
   @dateien_order = sort @dateien_order;
   foreach my $string (@dateien_order) {
      ($order_number,$aufgabe) = split(/___/, $string);
      $order_number=&get_order_number($aufgabe);
      my $aufgaben_name=&lastname_von_abs_pfad($aufgabe);
      my $aufgaben_name_ohne_tex = $aufgaben_name;
      $aufgaben_name_ohne_tex=~s/.tex//g;
      print PROBLECTIX "\\nehme{$aufgaben_name_ohne_tex}\n"; 
# this is handled in the aufgabe header
#         print PROBLECTIX '\marginpar{',"$order_number","}\n\n"; 
  }
}



sub html_seite_erstellen {
   my ($name, @dateien) = @_;
   my $aufgabe="";
   # Aufgabendatei erstellen
   open(AUFGABEHTML, ">$out_html/$name.html");
    print AUFGABEHTML '<html>',"\n";
    print AUFGABEHTML '<head>',"\n";
    print AUFGABEHTML '<title>Verzeichnis: &nbsp;',"$name",'</title>',"\n";
    print AUFGABEHTML '</head>',"\n";
    print AUFGABEHTML '<body bgcolor=#E8EBFF>',"\n";
    print "\n###  Creating $name.html:\n";
    # Die Aufgaben verarbeiten
    foreach $aufgabe (@dateien) {
       #print "$aufgabe  \n\n\n";
       my $aufgaben_name=&lastname_von_abs_pfad($aufgabe);
       my $aufgaben_name_ohne_tex = $aufgaben_name;
       $aufgaben_name_ohne_tex=~s/.tex//g;
       my $png_name = "$aufgaben_name"."-gen.png";

       if ($verbose>0){
           print "Working on $aufgaben_name\n";
       }

       # png-Grafik der Aufgabe erstellen
       &png_von_aufgabe($aufgabe);

       # Aufgabe einfügen in Verzeichnis.html
       print AUFGABEHTML '<h1 align="center">Einf&uuml;gebefehl:',
                         '  &nbsp; &nbsp; <tt>\nehme{';
       print AUFGABEHTML "$aufgaben_name_ohne_tex";
       print AUFGABEHTML '}</tt></h1>',"\n";
       print AUFGABEHTML '<h1 align="center">','<a href="',
                         "$aufgabe",
                         '">Quellcode ansehen ...</a></h1>';
       #print AUFGABEHTML '<hr noshade size="1">',"\n";
       print AUFGABEHTML '<img src="';
       print AUFGABEHTML "$png_name";
       print AUFGABEHTML '">',"\n";
       #print AUFGABEHTML '<hr noshade size="1">',"\n";

       for (my $i = 1; $i <= 5; $i++) {  # count from 1 to 5
        
           my $app=$out_html_browsetree."/".$png_name."-app".$i;
              if (-e $app){
                  my $letter;
                  if ($i==1){$letter="A"}
                  elsif ($i==2){$letter="B"}
                  elsif ($i==3){$letter="C"}
                  elsif ($i==4){$letter="D"}
                  elsif ($i==5){$letter="E"}
		  print "   $app found! Creating Link! \n";
                 print AUFGABEHTML '<h3 align="center">',
                                   '<a href="',"$app",
                                   '">Anhang ',$letter,
                                   ' ansehen </a></h3>';
	      }
          }


       print AUFGABEHTML '<h1 align="center">Einf&uuml;gebefehl:   &nbsp; &nbsp; <tt>\nehme{';
       print AUFGABEHTML "$aufgaben_name_ohne_tex";
       print AUFGABEHTML '}</tt></h1>',"\n";
       print AUFGABEHTML "\n",'<hr noshade size="6">',"\n\n";

    }

    # Dateiende
    print AUFGABEHTML '<hr noshade size="10">',"\n";
    print AUFGABEHTML '</body>',"\n";
    print AUFGABEHTML '</html>',"\n";
    return; 
}


sub verzeichnis_vorbereiten {
   #Verzeichnis anlegen
   if ($count_prob==1){
      # do nothing
   } elsif ($www==0) {
      # Fuer Postscript
      if (not (-e "$out_ps")){
         system ("mkdir $out_ps");
      } elsif ($renew==1) {
         rmtree("$out_ps"); 
         system ("mkdir $out_ps");
      } else {
         print "Verzeichnis $out_ps existiert bereits.\n";
         print "Mit der option --renew wird das verzeichnis\n";
         print "$out_ps mit dem gesamten Inhalt gelöscht ";
         print "und wieder neu erzeugt. \n\n";
      }
   } elsif ($www==1) {
      # Fuer HTML
      if (not (-e "$out_html")){
         system ("mkdir $out_html");
      } elsif ($renew==1) {
         rmtree("$out_html"); 
         system ("mkdir $out_html");
      } else {
         print "Verzeichnis $out_html existiert bereits.\n";
         print "Mit der option --renew wird das verzeichnis\n";
         print "$out_html mit dem gesamten Inhalt gelöscht ";
         print "und wieder neu erzeugt. \n\n";
      }
   }
}





sub index_datei_beginnen {
   if ($count_prob==1){
      # do nothing
   } elsif ($www==0) {
      # aufgabensammlung.tex erstellen
      ## Epochenzeit in Sekunden seit 1.1.1970. 
      my $epoch_now=time;

      my $now=localtime($epoch_now);
      my $sec=$now->sec;
      my $min=$now->min;
      my $hour=$now->hour;
      my $day=$now->mday;
      my $month=$now->mon+1;
      my $year=$now->year+1900;
      $month=&add_zero($month);
      $day=&add_zero($day);
      $hour=&add_zero($hour);
      $min=&add_zero($min);
      my $timestamp=$year."-".$month."-".$day." ".$hour.":".$min;
      
      my $username=`whoami`;
      chomp($username);
      if (defined $username and $username ne ""){
          $username=$username.", ";
      } else {
          $username="";
      }

      print "$out_ps/$active-$type_name.tex\n\n";
      open (PROBLECTIX, ">$out_ps/$active-${type_name}.tex") 
         || die "Fehler($out_ps/$active-${type_name}.tex): $!";
      if ($schueler==1){
        print PROBLECTIX "\\documentclass[col,$layout]{teacher}\n";
        print PROBLECTIX "\\Titelo{Aufgabensammlung}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\Datum{}\n";
        print PROBLECTIX "\\Fach{Mathematik}\n";
        print PROBLECTIX "\\gruppeb\n\n";
        print PROBLECTIX "\\begin{document}\n";
        print PROBLECTIX "\\Ausdruck{$timestamp ",
                         "$username\\texttt{$string_printout}}\n\n";
        print PROBLECTIX "\\DocType{Aufgabensammlung}\n";
        print PROBLECTIX "\\chead{\\bfseries \\leftmark}\n\n";
      } elsif ($exam==1) {
        print PROBLECTIX "\\documentclass[exam,$layout]{teacher}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\Datum{}\n";
        print PROBLECTIX "\\gruppeb\n\n";
        print PROBLECTIX "\\begin{document}\n\n";
        print PROBLECTIX "\\Ausdruck{$timestamp ",
                         "$username\\texttt{$string_printout}}\n\n";
      } elsif ($kamulti==1) {
        print PROBLECTIX "\\documentclass[kamulti,$layout]{teacher}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\Datum{}\n";
        print PROBLECTIX "\\gruppeb\n\n";
        print PROBLECTIX "\\begin{document}\n\n";
        print PROBLECTIX "\\Ausdruck{$timestamp ",
                         "$username\\texttt{$string_printout}}\n\n";
      } elsif ($lehrer==1) {
        print PROBLECTIX "\\documentclass[$layout]{teacher}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\Datum{}\n";
        print PROBLECTIX "\\gruppeb\n\n";
        print PROBLECTIX "\\begin{document}\n\n";
        print PROBLECTIX "\\Ausdruck{$timestamp ",
                         "$username\\texttt{$string_printout}}\n\n";
            } elsif ($loesung==1) {
        print PROBLECTIX "\\documentclass[lsg,$layout]{teacher}\n";
        print PROBLECTIX "\\pagestyle{empty}\n";
        print PROBLECTIX "\\gruppea \n";
        print PROBLECTIX "\\Titelo{Aufgabensammlung}\n";        
        print PROBLECTIX "\\Fach{Mathematik}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\DocType{Aufgabensammlung}\n";
        print PROBLECTIX "\\begin{document}\n\n";
        print PROBLECTIX "\\Ausdruck{$timestamp ",
                         "$username\\texttt{$string_printout}}\n\n";
        print PROBLECTIX "\\chead{\\bfseries \\leftmark}\n\n";
      } else {
	print "Eine der Optionen:\n\n";
	print "  --student (Nur Aufgaben)\n";
	print "  --exam   (Aufgaben, Leerbereiche, ...)\n";
	print "  --kamulti   (Aufgaben, Leerbereiche, ...)\n";
	print "  --teacher   (Aufgaben, Lösungen, Dateinamen, ...)\n";
	print "  --solution  (Lösungsblatt)\n";
	print "  --count     (Aufgaben zählen)\n";
	print "\nmuss angegeben werden.\n\n";
 
        print "Hilfe:  problectix --help \n\n";
        print "Oder :  man problectix  \n\n";

	exit;
      }
   } elsif ($www==1) {
      # index.html erstellen
      open (INDEX, ">$out_html/index.html") || die "Fehler: $!";
      print INDEX "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n";
      print INDEX "<html>\n<head>\n";
      print INDEX "<TITLE>Aufgabensammlung</TITLE>\n";
      print INDEX "</head>\n<body bgcolor=#E8EBFF>\n";
      # Titel noch grösser (Bild???????????????)
      print INDEX "<h1>Aufgabensammlung</h1>\n";
   }
}




sub last_exit {
   if ($count_prob==1){
      # dont compile anything
   } elsif ($www==0) {
      # aufgabensammlung schliessen
      print PROBLECTIX "\n\\end{document}\n";
      close(PROBLECTIX);
      print "here  I am: $out_ps\n";
      print "TEX: $active-$type_name.tex\n";
#      system ("problectix.sh","$out_ps","$active-$type_name");
      system ("cd $out_ps; jefflatex --silent-dvips --file $active-$type_name");
   } elsif ($www==1) {
      # Index.html schliessen
      print INDEX "</body>\n<html>\n";
      print INDEX "\n";
      close(INDEX);
   }
   # BEENDEN
   print "\nVerzeichnisliste ist abgearbeitet.\n\n";
   if ($browsetree==1) {
      &write_png_db;
   }

   if ($count_prob==1){
       print "\n$counter_problems Aufgaben\n\n";
   }

   # Programmende
   exit;

}




sub write_png_db {
   # png_db schreiben
    if ($verbose>0){
        print "Writing the PNG-Database to $out_html_browsetree/pngdb ... ";
    }
    open (PNGDB, ">$out_html_browsetree/pngdb");
    while (($key,$value) = each %png_db){
      print PNGDB "$key"."::"."$value"."\n";
    }
    close(PNGDB);
}



sub read_png_db {
   # png_db schreiben
    my ($file,$date);       
    print "Checking for a PNG-Database ... \n";
    if (-e "$out_html_browsetree/pngdb"){
       print "... PNG-Database exists, reading ... \n";
       open (PNGDB, "<$out_html_browsetree/pngdb");
       while (<PNGDB>) {
	   chomp();
           ($file,$date)=split(/::/);
           $png_db{$file}=$date; 
           if ($verbose>1){
               print "   $file was modified at $date \n";       
           }
       }
       close(PNGDB);
   } else {
       print "... PNG-Database does not exist, creating ...\n";
   }
}



sub add_zero {
    my ($value) = @_;
    if (exists $add_zero{$value}){
        $value = $add_zero{$value};
    }
    return $value;
}


sub print_lines {
    my ($path,$num) = @_;
    open (READ, "<$path") || die "$path: $!";
    my $min_line=$num-2;
    my $max_line=$num+2;
    my $line=1;
    while (<READ>){
        chomp();
        if ($line==$num){
            printf  " %3s>>>%-90s\n",$line,$_;
        } else {
            printf  " %3s>  %-90s\n",$line,$_;
        }
        $line++;
    }
    close READ;
}
