#!/usr/bin/perl -w
# Dieses Script (problectix-collection) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de

# Bibliotheken
use strict;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use File::Find;
use File::Path; # rmtree, ...
#use Schedule::at;

use problectix;

# Einlesen der Konfigurationsdatei für Entwickler
#{ package DevelConf ; do "/etc/sophomorix/devel/user/sophomorix-devel.conf"}

# jeffbecks Bibliothek und
# Einlesen der Konfigurationsdatei
#require "${DevelConf::library_pfad}/sophomorix-lib";

# in allen Pfad-ausgaben soll /home/bz fehlen


# www: 
# in usermin: cgi-script, dass source-code sucht. wird mit dem aufgerufen
# oder abs-pfad mitspeichern und link anlegen: file:///
# evtl. letzte Möglichkeit: beim erstellen der aufgaben(.tex->png) abspeichern



# überlegen: option www nimmt immer alle Aufgaben 
# (in --schueler, --lehrer, und --loesungs-Version)
# --lehrer: links auf src
# --schueler: keine links auf source
#             beliebiger zielpfad angebbar (z.B. Public_html)
# --loesung
# bel. Zielpfad

# in *.conf eine LISTE mit Aufgabentrees, sie machen die Gesamtmenge 
# der Aufgaben aus
# Aus dieser Gesamtmenge können Projekte zusammengefasst werden
# diese Pfade müssen in $TEXINPUTS enthalten sein
# am besten diese Variable auswerten, sonst muss man alles doppelt machen
# usermin: wenn $texinputs lerr, dann entspr. Meldung was durchsuchen

# Check-Script, dasauf solche Fehler hin prüft und tipps gibt
# Error erzeugen, wenn derselbe Dateinamen doppelt vorkommt


# Beim Erstellen von png's sollen nur die veränderten *.tex-dateien neu compiliert
# werden 



#USERMIN

# Main Pages
#  - Projects
#        - aktives Projekt
#           <ps loesung erzeugen>
#           <ps lehrer>
#           <ps schueler>
#           <html> ...
#        - andere Projekte auflisten
#           <aktivieren> <bearbeiten>


#  - Konfiguration
#       - texinputs konfigurieren
#       - ...

# - Aufgabe erstellen
#   (Datei Temporär in extraverzeichnis halten,
#    dort editieren, kompilieren, prüfen.
#    wenn erfolgreich abgeschlossen, dann in ein Verzeichnis einordnen)
#       - Vorlage auswählen(png-preview) 
#       - Editorfenster (html)
#       
# - CVS-Server-Modul
#       -einchecken/auschecken
#       -konfigurieren

# Hash mit Verzeichnissen, in denen nicht mehr weitergesucht werden soll
my %exclude_dirs = qw(ARB ignore
                      WORK ignore
                      FOL ignore
                      FOIL ignore
                      BB ignore
                     );

my @projects=();
# Datenbank für alle erzeugten png's
my %png_db=();
my $key;
my $value;
# ==========================================================================
# Variablen für Optionen
# ==========================================================================
my $help=0;
my $info=0;
my $set="";
my $start_path="";
my $command_line_path="";
my $abs_command_line_path="";
my $www=0;
my $ps=0;
my $renew=0;
my $schueler=0;
my $loesung=0;
my $lehrer=0;
my $type_name="";
my $uebung=0;
my $browsetree=0;
my $order=0;
my $create="";
my $remove="";
my $match_uebung="";
my $layout="";


my $order_number="777";

my $out_path="";
my $out_ps="";
my $out_ps_browsetree="";
my $out_html="";
my $out_html_browsetree="";



my $project_number=0;
my $active;

my @dir_list=();

# $HOME ermitteln
my $home="$ENV{'HOME'}";
# print "Homeverzeichnis ist:     \n  $home \n\n";   

### KONFIGURATION

# systemweite Konfiguration
my $sys_config = "/etc/problectix/problectix.conf";
# userabhaengige Konfiguration
my $config_dir="$ENV{'HOME'}/.problectix";
my $user_config="$config_dir"."/.problectix";
# projekte eines users
my $project_dir="$config_dir/projects";
# aktives projekt eines users
my $active_project="$project_dir"."/.project";



# ===========================================================================
# Konfigurations-Dateien sourcen
# ==========================================================================

# Abbruch, falls sysweite config fehlt
if (not -e $sys_config) {
    print "$sys_config does not exist. exiting ...\n\n";
    exit;
} else {
   # werte der sysconfig einlesen
   { package SysConf ; do "$sys_config"}
    $out_path="$SysConf::output_path";
    $start_path="$SysConf::start_path";
}



# userweit, falls existent
if (-e "$user_config") {
   { package UserConf ; do "$user_config"}
   $out_path="$UserConf::output_path";
   $start_path="$UserConf::start_path";
}



# dummy
if($SysConf::output_path){};
if($SysConf::start_path){};
if($UserConf::output_path){};
if($UserConf::start_path){};



# ===========================================================================
# Optionen verarbeiten
# ==========================================================================
# Parsen der Optionen
my $testopt=GetOptions(
           "info|i" => \$info,           
           "set=s" => \$set,           
           "help|h" => \$help,
           "www" => \$www,
           "ps" => \$ps,
           "schueler|s" => \$schueler,
           "lehrer|l" => \$lehrer,
           "loesung|lsg" => \$loesung,
           "renew" => \$renew,
           "order|o" => \$order,
           "browsetree" => \$browsetree,
           "create=s" => \$create,
           "remove=s" => \$remove,
           "uebung|u" => \$uebung,
           "layout=s" => \$layout,
           "pfad|path|p=s" => \$command_line_path
          );



# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

if ($ps==1 and $www==1) {
    print "You cannot say --www AND --ps\n\n";
    exit;
}

# --schueler, --lehrer, --loesung
if ($schueler==1){
    $type_name="schueler";
} elsif ($lehrer==1){
    $type_name="lehrer";
} elsif ($loesung==1){
    $type_name="loesung";
} elsif ($browsetree==1){
    # option browsetree
    # wenn nichts anderes angegeben, dann lehrer(Aufgabe und Lösung)
    $type_name="lehrer";
    $lehrer=1;
} else {
    $type_name="(schueler/lehrer/loesung)";
}


# --path
if ($command_line_path ne "") {
    # pfad muss absolut angegeben werden
    # ????? relativer Pfad umbiegen
    $start_path = $command_line_path;
}


# --create
if ($create ne "") {
    if ($command_line_path eq "") {
	print "Um ein Projekt zu erstellen muss",
              " --path pfadname angegeben werden.\n";
        exit;
    }
    # / am ende anfügen (Verzeichnis)
    if (not $command_line_path=~/\/$/){
        $command_line_path="$command_line_path"."/";
    }
    # Absoluten Pfad ermitteln
    if ($command_line_path=~/^$home/){
        $abs_command_line_path=$command_line_path;
    } else {
        $abs_command_line_path=$home."/"."$command_line_path";
    }
    # erstellen, falls existent
    if (-e "$abs_command_line_path"){
        # make dir relative
        $command_line_path=$abs_command_line_path;
        $command_line_path=~s/^$home\///;  
        # creating the project
        print "Erstelle Projekt $create ...\n";
        open(NEWPRO, ">$project_dir/$create") || 
            die "Cannot create $project_dir/$create\n";
        print NEWPRO "$command_line_path\n";
        close(NEWPRO);
        # making the project active, when no project is active
        $active=&problectix::get_active_project();
        if (not defined $active) {
            print "Projekt $create wird aktiviert.\n";
            # neues Link anlegen
            system("cd $project_dir; ln -s $create .project");
        }
    } else {
	print "ERROR: Konnte Projekt nicht erstellen:\n";
	print "  $abs_command_line_path existiert nicht!\n";
        exit;
    }
}


# Handling the active project
$active=&problectix::get_active_project();


# Determining the browsetree-dirs
$out_html_browsetree="$SysConf::browsetree_path/html-$type_name";
$out_ps_browsetree="$SysConf::browsetree_path/ps-$type_name";

# --browsetree
if ($browsetree==0) {
    print "\nDas aktive Projekt ist:  \n",
          "  $active \n";   
    $out_ps="$out_path"."/$active";
    $out_html="$out_path"."/html/$active";
    # sicherstellen, dass Output_dir existiert
    if (not -e $out_path){
        print "Creating $out_path ...\n";
        system("mkdir $out_path");
    }
} else {
    # option browsetree
    #print "Option browsetree angegeben.\n";
    $out_html="$out_html_browsetree";
    $out_ps="$out_ps_browsetree";
    $active="Aufgabensammlung";
    print "\nDer html-browsetree wird erstellt in: \n",
          "   $out_html \n";
    # Bei renew den ganzen bisherigen tree löschen
    if (not -e $SysConf::browsetree_path) {
        # Anlegen
        print "Creating $SysConf::browsetree_path ...\n";
        system("mkdir $SysConf::browsetree_path");
    } elsif ($renew==1) {
         # Löschen und neu anlegen
         rmtree("$SysConf::browsetree_path"); 
         system ("mkdir $SysConf::browsetree_path");
    }
    &read_png_db();
}



# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print "$scriptname erzeugt eine Aufgabensammlung aus einem \n";
   print "Verzeichnis von Aufgaben im *.tex-Format.\n";

   # optionen
   print "\nOptionen:\n\n";

   print "  --info, -i\n";
   print "     Alle Dateien anzeigen, die verarbeitet werden. \n";

   print "  --create projektname\n";
   print "     Erstellt ein neues Projekt mit dem Namen projektname.\n";
   print "     Wenn diese Option verwendet wird, muss zusätzlich ein Pfad\n"; 
   print "     angegeben werden (siehe Option path).\n";

   print "  --remove projektname\n";
   print "     Entfernt ein vorhandenes Projekt mit dem Namen projektname.\n";

   print "  --pfad verzeichnis, --path verzeichnis, -p  verzeichnis\n";
   print "     Angabe in welchem verzeichnis soll nach *.tex-Dateien \n";
   print "     gesucht werden soll.\n";

   print "  --browsetree\n";
   print "     Bearbeitet ALLE Aufgaben (=Aufgabensammlung), anstelle nur\n";
   print "     die Aufgaben des aktiven Projekts zu berücksichtigen.\n";
   print "     Die Aufgabensammlungen werden erstellt in:\n";
   print "        $SysConf::browsetree_path\n";

   print "  --www\n";
   print "     Erzeugt ein Verzeichnis \n";
   print "       $out_html \n";
   print "       $out_html_browsetree \n";
   print "     mit html-Dateien, die für jede Aufgabe auf ein *.png verlinken.\n";

   print "  --uebung, -u\n";
   print "     Nutzt nur Dateien, die mit \"-U.tex\" enden.\n";
   print "     (Übungsaufgaben)\n";

   print "  --schueler, -s\n";
   print "     Erzeugt eine Aufgabensammlung für Schüler.\n";
   print "     (ohne Ergebnisse, ohne Lösungslinien)\n";

   print "  --lehrer, -l\n";
   print "     Erzeugt eine Aufgabensammlung für lehrer incl. Lösung und \n";
   print "     Lösungslinien.\n";

   print "  --loesung, -lsg\n";
   print "     Erzeugt ein Lösungsblatt.\n";

   print "  --set n\n";
   print "     Setzt das Projekt n aktiv. (n=1,2,3,...)\n";
   print "     Eine Liste der moeglichen Projekte erhaelt man mit ?????\n";

   print "  --renew\n";
   print "     Löscht das Ausgabe-Verzeichnis $out_html, um es neu\n";
   print "     zu erzeugen. ACHTUNG: Bei Änderung der Konfigurationsdateien\n";
   print "     können IHRE Vereichnisse gelöscht werden!\n";

   print "\n";

   exit;
}



# --uebung
if ($uebung==1) {
   $match_uebung="-U";
}

# Ausgabe der gueltigen Werte
print "\nNach Aufgaben wird gesucht in:\n",
      "   $start_path\n";
print "\nDie Projekt-Aufgabensammlungen werden erstellt in:\n",
      "   $out_path\n";
print "\nDie Gesamt-Aufgabensammlungen werden erstellt in:\n",
      "   $SysConf::browsetree_path\n";
print "\nDie Projekte sind definiert in:  \n",
      "   $project_dir \n";   

# sicherstellen, dass Projektverzeichnis existiert
if (not -e $config_dir){
    print "Creating $config_dir ...\n";
    system("mkdir $config_dir");
}
if (not -e $project_dir){
    print "Creating $project_dir ...\n";
    system("mkdir $project_dir");
}



# --remove
if ($remove ne "") {
    if (-e "$project_dir/$remove") {
      # removing the project
      print "Entferne Projekt $remove ...\n";
      system("rm $project_dir/$remove");
      print "Done.\n";
      print "Daten in $out_path/$remove habe ich nicht gelöscht.\n";
  } else {
      print "\nFEHLER::Konnte die zum löschenden Projekt gehörende Datei\n";
      print "   $project_dir/$remove \n";
      print "nicht finden.\n\n";
  }
  exit;
}



# Abbruch, falls kein aktives Projekt existiert
if (not defined $active){
    print "\nEs gibt kein aktives Projekt\n";
    print "Legen sie ein Projekt an mit der option --create\n";
    print "Siehe auch in der Hilfe ( --help)\n\n";
    exit;
}



# Start-verzeichnis-name ermitteln
# start-path = absolut
#start-dir   = Verzeichnis-Name
my @list = split(/\//,$start_path);
my $start_dir = pop @list;

# Welche Verzeichnisse durchsucht werden müssen
# Am Beginn nur das Startverzeichnis
my @verzeichnisliste=($start_dir);




# --info
if ($info==1 or $set ne "") {
    #print "\n\nGefundene *.tex-Dateien:\n";
    #foreach my $datei (@tex_dateien) {
	#print "$datei\n";
    #}
    #exit;
  
    # Projekt-Liste zum setzen erstellen
    @projects=&problectix::get_project_list();

    print "\nProjekte:\n";

    if ($set ne "") {
        # anderes projekt aktivieren
        if (defined $projects[$set]){
           # sinnvoller wert übergeben 
           print "setze aktives Projekt auf $set\n";
           # altes Link entfernen
           print "$active_project\n";
           unlink $active_project;
           # neues Link anlegen
           system("cd $project_dir; ln -s $projects[$set] .project");
           # Projekt-Liste aktualisieren zum Anzeigen
           @projects=&problectix::get_project_list();
        } else {
           # sinnloser Wert uebergeben
	   print "\nAbbruch:\n";
           print "Es gibt kein Projekt mit dem Index $set\n";
           exit;
        }
    } else {
        # nichts tun
        #print "setze nicht\n";
    }

    # Liste aller Projekte ausgeben
    foreach my $project (@projects){        
        my @dir_listing=&problectix::get_dirlist_of_project($project);
        # Nummer des Projects ausgeben
        if ($project_number==0){
           print "   (*)";
        } else {
	   print ("   ($project_number)");
        }
        # Name des Projekts ausgeben
        print "$project\n";
        # Liste der Verzeichnisse ausgeben
        foreach my $dir (@dir_listing) {
         print "    -- $dir\n";
        }
        $project_number++;
    }
    # beenden der --info-Option
    exit;
}







# ===========================================================================
# Aufgabensammlung erzeugen
# ==========================================================================

# Projekt oder Alle Aufgaben?
if  ($browsetree==0) {
   # Projektliste erstellen, in erstem Element ist das Standardprojekt
   my @project_list=&problectix::get_project_list();
   @dir_list=&problectix::get_dirlist_of_project($project_list[0]);
} else {
   # Alle Aufgaben
   @dir_list=($start_path);   
}



&aufgabensammlung(@dir_list);







# ===========================================================================
# Subroutinen
# ==========================================================================

sub get_order_number{
    my ($aufgabe) = @_;
    # Standardwert
    my $order="9999";
    my $a;
    #print "Aufgabe: $aufgabe\n";
    open (AUORDER, "<$aufgabe") || die "$aufgabe: $!";
    while (<AUORDER>){
        chomp();   
        s/\s//g;
        s/%//g;
        if (/order=/) {
	  ($a, $order)=split(/=/);
        next;
        }
    }
    close(AUORDER);
    return "$order";
}



sub png_von_aufgabe{
    # Parameter ist der absolute Dateipfad
    # der *.tex-Datei mit der Aufgabe
    my ($datei_pfad) = @_;
    my @list = split(/\//,$datei_pfad);
    my $datei = pop @list;
    my $datei_ohne_tex = $datei;
    my $gen_png="$out_html"."/"."$datei"."-gen.png";
    my $order_number=&get_order_number($datei_pfad);
    # decide if a new png is needed
    my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev,
    $size, $atime, $mtime, $ctime, $blksize, $blocks)
    = stat($datei_pfad);
    # print " Checking if I should create  $gen_png\n\n";
    if (not exists $png_db{$datei} or 
       (not -e $gen_png) or
       (exists $png_db{$datei} and $png_db{$datei} ne $mtime)){
           # create a png
           $datei_ohne_tex=~s/.tex//g;
           print "$datei: Creating $gen_png\n";
      #     if (not exists $png_db{$datei}) {
      #         print "Reason: $png_db{$datei} existiert nicht in der Datenbank!\n";
      #     } elsif (not -e $gen_png){
      #         print "Reason: Datei $gen_png existiert nicht!\n";
      #     }elsif (exists $png_db{$datei} and $png_db{$datei} ne $mtime){
      #         print "Reason: $png_db{$datei} existiert in der Datenbank\n";
      #         print "mit derZeit $png_db{$datei} und Dateizeit $mtime\n";
      #     } else {
      #	       print "Wohl ein Fehler\n";
      #	   }

           open(AUFGABE, ">$out_html/temp-datei.tex");
           if ($schueler==1){
             print AUFGABE '\documentclass[arb,leer]{teacher}',"\n";
           } elsif ($lehrer==1) {
             print AUFGABE '\documentclass[leer]{teacher}',"\n";
           } elsif ($loesung==1) {
             print AUFGABE '\documentclass[lsg,leer]{teacher}',"\n";
           } else {
	     print "No option Found (lehrer/schueler/loesung)\n\n";
             exit;
           }
           print AUFGABE '\special{papersize=210mm,697mm}',"\n";
           print AUFGABE '\pagestyle{empty}',"\n";
           print AUFGABE '\gruppea',"\n";
           print AUFGABE '\setcounter{aufgabennummer}{0}',"\n\n";
           print AUFGABE '\begin{document}',"\n";
           print AUFGABE '\enlargethispage{600mm}',"\n";
           # Einfügen der benötigten Dateien
           print AUFGABE '\nehme{',"$datei_ohne_tex",'}',"\n";
           if ($order==1) {
              print AUFGABE '\marginpar{',"$order_number",'}',"\n\n";
           }
           print AUFGABE '\end{document}',"\n";
           close(AUFGABE);

           system("tex2png.sh $out_html $datei_ohne_tex");
           system("cd $out_html; rm temp-datei.aux");
           system("cd $out_html; rm temp-datei.log");
           system("cd $out_html; rm temp-datei.tex");
           system("cd $out_html; rm temp-datei.dvi");
           system("cd $out_html; rm temp-datei.ps");
           # neuer Datenbankeintrag machen
           $png_db{$datei}=$mtime;
#       }
       } else {
           print "$datei: I do not need to create a *.png.\n";
       }
}





sub aufgabensammlung {
    # Übergeben wurde der Start-Pfad
    # Dieser ist nun als einziges in der Verzeichnisliste
    my @verzeichnisliste = @_;
    my @tex_list = ();
    my $work_dir;

    &verzeichnis_vorbereiten();
    &index_datei_beginnen();

   # Beginn der while-Schleife, solange es Verzeichnisse gibt
   while (1==1) {
      # Erstes Element aus der Verzeichnisliste holen 
      # (Element wird aus array entfernt)
      # $work_dir ist enthält absoluten Pfad
      $work_dir = shift(@verzeichnisliste);
 
      # Ausstieg, wenn @verzeichnisliste leer ist
      if (not defined $work_dir) {
          # Programmende
          &last_exit();
      }

      # $dir   : Verzeichnisname (ohne Pfad) 
      my @pathlist = split(/\//,$work_dir);
      my $dir = pop @pathlist;
      # Pfadliste leeren
      @pathlist = ();

      # Gibt es *.tex-Dateien
      @tex_list=&list_tex_dateien($work_dir);
   
      # Gibt es Verzeichnisse
      my @dir_list=&list_dirs($work_dir);
  
      if (defined $tex_list[0]) {
          # Tex-Dateien bearbeiten, falls Liste nicht leer
          if ($www==0) {
	      &tex_eintraege($dir,@tex_list);
          } elsif ($www==1) {
             #print "\n\nDIR: $dir\n\n";
             #print "Liste:  @tex_list\n\n";
             &html_seite_erstellen($dir,@tex_list);
          }
          # Link auf diese Datei Erstellen in index.html
          if ($www==0) {
          # nichts tun
          } elsif ($www==1) {
            print INDEX "<h3><A HREF=\"",
                        "$dir.html",
                        "\">",
                        "$dir",
                        "</A></h3>",
                        "\n";
          }
      } elsif (not defined $dir_list[0]) {
          # mini-Überschrift erstellen (Verzeichnis ist leer)
          if ($www==0) {
             print PROBLECTIX "\n","\\section{",
                              "$dir (noch keine Aufgaben)}\n";
          } elsif ($www==1) {
             print INDEX '<h4>',"$dir"," &nbsp; (noch keine Aufgaben)",
                         '</h4>',"\n";
          }      
      } else {
          # Große Überschrift (übergeordnetes Verzeichnis)
          if ($www==0) {
   
          } elsif ($www==1) {
             print INDEX '<h1>',"$dir",'</h1>',"\n";
	  }
      }

      # Verzeichnisse in Verzeichnisliste laden
      unshift @verzeichnisliste, @dir_list;

   }# Ende der While-Schleife

}



# Diese Subroutine bekommt als Argment den Parsewert der Funktion GetOptions.
# Ist dieser nicht 1, so wurde eine Fehlerhafte Option vergeben
sub  check_options{
   my ($parse_ergebnis) = @_;
   if (not $parse_ergebnis==1){
      my @list = split(/\//,$0);
      my $scriptname = pop @list;
      print "\nSie haben bei der Eingabe der Optionen einen Fehler begangen.\n"; 
      print "Siehe Fehlermeldung weiter oben. \n\n";
      print "... $scriptname beendet sich.\n\n";
      exit;
   } else {
         print "Alle Befehls-Optionen wurden erkannt.\n";
   }

}



sub lastname_von_abs_pfad {
    # Parameter: absoluter Pfad
    # sub gibt letzter Name (Verzeichnis oder Datei) zurück
    my ($abs_pfad) = @_;
    my @pathlist = split(/\//,$abs_pfad);
    my $lastname = pop @pathlist;
    return $lastname;
}



sub list_tex_dateien {
   # Gibt alle *.tex-Dateien des übergebenen Verzeichnisses zurück
    my ($verzeichnis) = @_ ;
    my @tex_dateiliste = ();
    print "\nSuche *.tex-Dateien im Verzeichnis $verzeichnis ...\n";
    opendir(DIR, $verzeichnis) || die "Kann $verzeichnis nicht öffnen: $!";
    while (defined (my $file = readdir(DIR))) {
        # Eintrag verarbeiten
        print "<br>Gefunden: $file     ---";
        if ($file=~/${match_uebung}.tex$/
            ) {
	    print "ist eine *.tex-Datei\n";
            $file="$verzeichnis"."/"."$file";
            push (@tex_dateiliste, $file);
        } else {
	    print "keine *.tex-Datei\n";
        }
    }
    print "<p>\n";
    closedir(DIR);
    return @tex_dateiliste;
}



sub list_dirs {
   # Gibt alle Verzeichnisse des übergebenen Verzeichnisses zurück
   # ohne die in der exclude-liste enthaltenen
    my ($verzeichnis) = @_ ;
    my @dirs = ();
    print "\nSuche Verzeichnisse im Verzeichnis $verzeichnis ...\n";
    opendir(DIR, $verzeichnis) || die "Kann $verzeichnis nicht öffnen: $!";
    while (defined (my $eintrag = readdir(DIR))) {
        my $abs_eintrag="$verzeichnis"."/"."$eintrag";
        # Eintrag verarbeiten
        print "<br>Gefunden. $eintrag --- ";
        if (-d $abs_eintrag &&  # verbessern ?????????????????
               $eintrag ne "auto" && 
               $eintrag ne ".xvpics" && 
               $eintrag ne "." &&
               $eintrag ne "CVS" &&
               $eintrag ne "..") {
 	    print " ist Verzeichnis\n";
            if (exists $exclude_dirs{$eintrag}){
                print "... Verzeichnis $eintrag wird ignoriert!\n";
            } else {
                push (@dirs, $abs_eintrag);
	    }
        } else {
            print " KEIN Verzeichnis\n";  
	}
        
    }
    closedir(DIR);
    @dirs = sort @dirs;
    return @dirs;
}



sub tex_eintraege {    
   my ($name, @dateien) = @_;
   my @dateien_order=(); 
   my $aufgabe="";
   my $order_number="99999";
   print PROBLECTIX "\n","\\section{$name}\n";
   foreach $aufgabe (@dateien) {
       $order_number=&get_order_number($aufgabe);
       push (@dateien_order, "$order_number"."___"."$aufgabe");
   }
   @dateien_order = sort @dateien_order;
   foreach my $string (@dateien_order) {
      ($order_number,$aufgabe) = split(/___/, $string);
      $order_number=&get_order_number($aufgabe);
      my $aufgaben_name=&lastname_von_abs_pfad($aufgabe);
      my $aufgaben_name_ohne_tex = $aufgaben_name;
      $aufgaben_name_ohne_tex=~s/.tex//g;
      print PROBLECTIX "\\nehme{$aufgaben_name_ohne_tex}\n"; 
      if ($order==1) {
         print PROBLECTIX '\marginpar{',"$order_number","}\n\n"; 
      }
  }
}



sub html_seite_erstellen {
   my ($name, @dateien) = @_;
   my $aufgabe="";
   # Aufgabendatei erstellen
   open(AUFGABEHTML, ">$out_html/$name.html");
    print AUFGABEHTML '<html>',"\n";
    print AUFGABEHTML '<head>',"\n";
    print AUFGABEHTML '<title>Verzeichnis: &nbsp;',"$name",'</title>',"\n";
    print AUFGABEHTML '</head>',"\n";
    print AUFGABEHTML '<body bgcolor=#E8EBFF>',"\n";
    print "\nCreating $name.html:\n";
    # Die Aufgaben verarbeiten
    foreach $aufgabe (@dateien) {
       my $aufgaben_name=&lastname_von_abs_pfad($aufgabe);
       my $aufgaben_name_ohne_tex = $aufgaben_name;
       $aufgaben_name_ohne_tex=~s/.tex//g;
       my $png_name = "$aufgaben_name"."-gen.png";
       # print "Working on $aufgaben_name\n";
       # png-Grafik der Aufgabe erstellen
       &png_von_aufgabe($aufgabe);

       # Aufgabe einfügen in Verzeichnis.html
       print AUFGABEHTML '<h1 align="center">Einf&uuml;gebefehl:  &nbsp; &nbsp; <tt>\nehme{';
       print AUFGABEHTML "$aufgaben_name_ohne_tex";
       print AUFGABEHTML '}</tt></h1>',"\n";
       print AUFGABEHTML '<h1 align="center">','<a href="',"$aufgabe",'">Quellcode editieren ...(To do)</a></h1>';
       #print AUFGABEHTML '<hr noshade size="1">',"\n";
       print AUFGABEHTML '<img src="';
       print AUFGABEHTML "$png_name";
       print AUFGABEHTML '">',"\n";
       #print AUFGABEHTML '<hr noshade size="1">',"\n";
       print AUFGABEHTML '<h1 align="center">Einf&uuml;gebefehl:   &nbsp; &nbsp; <tt>\nehme{';
       print AUFGABEHTML "$aufgaben_name_ohne_tex";
       print AUFGABEHTML '}</tt></h1>',"\n";
       print AUFGABEHTML "\n",'<hr noshade size="6">',"\n\n";

    }


    # Dateiende
    print AUFGABEHTML '<hr noshade size="10">',"\n";
    print AUFGABEHTML '</body>',"\n";
    print AUFGABEHTML '</html>',"\n";
 
 
}


sub verzeichnis_vorbereiten {
   #Verzeichnis anlegen
   if ($www==0) {
      # Fuer Postscript
      if (not (-e "$out_ps")){
         system ("mkdir $out_ps");
      } elsif ($renew==1) {
         rmtree("$out_ps"); 
         system ("mkdir $out_ps");
      } else {
         print "Verzeichnis $out_ps existiert bereits.\n";
         print "Mit der option --renew wird das verzeichnis\n";
         print "$out_ps mit dem gesamten Inhalt gelöscht ";
         print "und wieder neu erzeugt. \n\n";
      }
   } elsif ($www==1) {
      # Fuer HTML
      if (not (-e "$out_html")){
         system ("mkdir $out_html");
      } elsif ($renew==1) {
         rmtree("$out_html"); 
         system ("mkdir $out_html");
      } else {
         print "Verzeichnis $out_html existiert bereits.\n";
         print "Mit der option --renew wird das verzeichnis\n";
         print "$out_html mit dem gesamten Inhalt gelöscht ";
         print "und wieder neu erzeugt. \n\n";
      }
   }
}





sub index_datei_beginnen {
   if ($www==0) {
      # aufgabensammlung.tex erstellen
      print "$out_ps/$active-$type_name.tex\n\n";
      open (PROBLECTIX, ">$out_ps/$active-$type_name.tex") 
         || die "Fehler($out_ps/$active-$type_name.tex): $!";
      if ($schueler==1){
        print PROBLECTIX "\\documentclass[arb,$layout]{teacher}\n";
        print PROBLECTIX "\\Titelo{Aufgabensammlung}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\Datum{}\n";
        print PROBLECTIX "\\Fach{Mathematik}\n";
        print PROBLECTIX "\\gruppeb\n\n";
        print PROBLECTIX "\\begin{document}\n";
        print PROBLECTIX "\\DocType{Aufgabensammlung}\n";
        print PROBLECTIX "\\chead{\\bfseries \\leftmark}\n\n";
      } elsif ($lehrer==1) {
        print PROBLECTIX "\\documentclass[$layout]{teacher}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\Datum{}\n";
        print PROBLECTIX "\\gruppeb\n\n";
        print PROBLECTIX "\\begin{document}\n\n";
      } elsif ($loesung==1) {
        print PROBLECTIX "\\documentclass[lsg,$layout]{teacher}\n";
        print PROBLECTIX "\\pagestyle{empty}\n";
        print PROBLECTIX "\\gruppea \n";
        print PROBLECTIX "\\Titelo{Aufgabensammlung}\n";        
        print PROBLECTIX "\\Fach{Mathematik}\n";
        print PROBLECTIX "\\Titelu{\\leftmark}\n";
        print PROBLECTIX "\\DocType{Aufgabensammlung}\n";
        print PROBLECTIX "\\begin{document}\n\n";
        print PROBLECTIX "\\chead{\\bfseries \\leftmark}\n\n";
      } else {
	print "Eine der Optionen:\n\n";
	print "  --schueler (Nur Aufgaben)\n";
	print "  --lehrer   (Aufgaben, Lösungen, Dateinamen, ...)\n";
	print "  --loesung  (Lösungsblatt)\n";
	print "\nmuss angegeben werden.\n\n";
 
        print "Hilfe:  --help\n\n";

	exit;
      }
      #print PROBLECTIX "\\begin{document}\n\n";
   } elsif ($www==1) {
      # index.html erstellen
      open (INDEX, ">$out_html/index.html") || die "Fehler: $!";
      print INDEX "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n";
      print INDEX "<html>\n<head>\n";
      print INDEX "<TITLE>Aufgabensammlung</TITLE>\n";
      print INDEX "</head>\n<body bgcolor=#E8EBFF>\n";
      # Titel noch grösser (Bild???????????????)
      print INDEX "<h1>Aufgabensammlung</h1>\n";
   }
}




sub last_exit {
   if ($www==0) {
      # aufgabensammlung schliessen
      print PROBLECTIX "\n\\end{document}\n";
      close(PROBLECTIX);
      print "here  I am: $out_ps\n";
      print "TEX: $active-$type_name.tex\n";
      system ("problectix.sh","$out_ps","$active-$type_name");
   } elsif ($www==1) {
      # Index.html schliessen
      print INDEX "</body>\n<html>\n";
      print INDEX "\n";
      close(INDEX);
   }
   # BEENDEN
   print "\nVerzeichnisliste ist abgearbeitet.\n\n";
   if ($browsetree==1) {
      &write_png_db;
   }
   # Programmende
   exit;
}




sub write_png_db {
   # png_db schreiben
    print "Writing the PNG-Database ... ";
    open (PNGDB, ">$out_html_browsetree/pngdb");
    while (($key,$value) = each %png_db){
      print PNGDB "$key"."::"."$value"."\n";
    }
    close(PNGDB);
    print "Done\n";
}



sub read_png_db {
   # png_db schreiben
    my ($file,$date);
    if (-e "$out_html_browsetree/pngdb"){
       print "Reading the PNG-Database ... \n";
       open (PNGDB, "<$out_html_browsetree/pngdb");
       while (<PNGDB>) {
	   chomp();
           ($file,$date)=split(/::/);
           $png_db{$file}=$date; 
           print "   $file was modified at $date \n";       
       }
       close(PNGDB);
       print "Done\n";
    }
}

